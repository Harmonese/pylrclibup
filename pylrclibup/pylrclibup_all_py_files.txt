./config.py


===== FILE: ./config.py =====

from __future__ import annotations

import os
from dataclasses import dataclass
from pathlib import Path
from typing import Optional


# -------------------- 常量（全局配置） --------------------

# LRCLIB API 根地址
LRCLIB_BASE = "https://lrclib.net/api"

# 预览歌词时显示的最大行数
PREVIEW_LINES_DEFAULT = 10

# HTTP 调用最大自动重试次数
MAX_HTTP_RETRIES_DEFAULT = 5

# 默认 User-Agent（可以在 CLI 里加个选项覆盖）
DEFAULT_USER_AGENT = "pylrclibup/0.1 (https://github.com/yourname/pylrclibup)"


# -------------------- AppConfig --------------------


@dataclass
class AppConfig:
    """
    全局配置对象：

    - tracks_dir: MP3 输入目录
    - lrc_dir: LRC 输入目录
    - done_tracks_dir: MP3 输出目录
    - done_lrc_dir: LRC 输出目录
    - preview_lines: 预览歌词时显示的最大行数
    - max_http_retries: HTTP 自动重试次数
    - user_agent: 发送给 LRCLIB 的 User-Agent
    """

    tracks_dir: Path
    lrc_dir: Path
    done_tracks_dir: Path
    done_lrc_dir: Path

    preview_lines: int = PREVIEW_LINES_DEFAULT
    max_http_retries: int = MAX_HTTP_RETRIES_DEFAULT
    user_agent: str = DEFAULT_USER_AGENT

    lrclib_base: str = LRCLIB_BASE

    pair_lrc_with_track_dir: bool = False

    @classmethod
    def from_env_and_defaults(
        cls,
        *,
        tracks_dir: Optional[str | Path] = None,
        lrc_dir: Optional[str | Path] = None,
        done_tracks_dir: Optional[str | Path] = None,
        done_lrc_dir: Optional[str | Path] = None,
        preview_lines: Optional[int] = None,
        max_http_retries: Optional[int] = None,
        user_agent: Optional[str] = None,
        pair_lrc_with_track_dir: bool = False,
    ) -> "AppConfig":
        """
        统一入口：综合考虑
          1. 显式传入（通常来自 CLI 参数）
          2. 环境变量
          3. 默认值

        优先级：参数 > 环境变量 > 默认
        """

        # ---- 路径类配置 ----
        # 默认基于当前工作目录（而不是包所在目录）
        cwd = Path.cwd()

        # 环境变量
        env_tracks = os.getenv("PYLRCLIBUP_TRACKS_DIR")
        env_lrc = os.getenv("PYLRCLIBUP_LRC_DIR")
        env_done_tracks = os.getenv("PYLRCLIBUP_DONE_TRACKS_DIR")
        env_done_lrc = os.getenv("PYLRCLIBUP_DONE_LRC_DIR")

        tracks = Path(
            tracks_dir
            or env_tracks
            or cwd / "tracks"
        )
        lrc = Path(
            lrc_dir
            or env_lrc
            or cwd / "lrc-files"
        )
        done_tracks = Path(
            done_tracks_dir
            or env_done_tracks
            or cwd / "done-tracks"
        )
        done_lrc = Path(
            done_lrc_dir
            or env_done_lrc
            or cwd / "done-lrc-files"
        )

        # ---- 数值配置 ----
        if preview_lines is None:
            # 若未显式指定，允许通过环境变量覆盖
            env_preview = os.getenv("PYLRCLIBUP_PREVIEW_LINES")
            if env_preview and env_preview.isdigit():
                preview_lines_val = int(env_preview)
            else:
                preview_lines_val = PREVIEW_LINES_DEFAULT
        else:
            preview_lines_val = preview_lines

        if max_http_retries is None:
            env_retries = os.getenv("PYLRCLIBUP_MAX_HTTP_RETRIES")
            if env_retries and env_retries.isdigit():
                max_http_retries_val = int(env_retries)
            else:
                max_http_retries_val = MAX_HTTP_RETRIES_DEFAULT
        else:
            max_http_retries_val = max_http_retries

        # ---- User-Agent ----
        ua = user_agent or os.getenv("PYLRCLIBUP_USER_AGENT") or DEFAULT_USER_AGENT

        return cls(
            tracks_dir=tracks,
            lrc_dir=lrc,
            done_tracks_dir=done_tracks,
            done_lrc_dir=done_lrc,
            preview_lines=preview_lines_val,
            max_http_retries=max_http_retries_val,
            user_agent=ua,
            pair_lrc_with_track_dir=pair_lrc_with_track_dir,
        )
./processor/__init__.py


===== FILE: ./processor/__init__.py =====

from .core import process_track, process_all

__all__ = ["process_track", "process_all"]./processor/core.py


===== FILE: ./processor/core.py =====

from __future__ import annotations

import sys
from pathlib import Path
from typing import Iterable, List, Optional

from ..config import AppConfig
from ..model import TrackMeta, LyricsRecord
from ..lrc import find_lrc_for_track, parse_lrc_file, ParsedLRC
from ..api import ApiClient, upload_lyrics, upload_instrumental
from ..fs import move_with_dedup, cleanup_empty_dirs


# -------------------- 日志 + 预览 --------------------


def _log_info(msg: str) -> None:
    print(f"[INFO] {msg}")


def _log_warn(msg: str) -> None:
    print(f"[WARN] {msg}")


def _log_error(msg: str) -> None:
    print(f"[ERROR] {msg}", file=sys.stderr)


def _preview(label: str, text: str, max_lines: int) -> None:
    print(f"--- {label} ---")
    if not text:
        print("[空]")
        print("-" * 40)
        return
    lines = text.splitlines()
    for ln in lines[:max_lines]:
        print(ln)
    if len(lines) > max_lines:
        print(f"... 共 {len(lines)} 行")
    print("-" * 40)


# -------------------- 文件移动 & 清理 --------------------

def _move_after_done(
    config: AppConfig,
    meta: TrackMeta,
    lrc_path: Optional[Path],
) -> None:
    """
    在以下场景调用：
      - /api/get-cached 已有歌词
      - 上传成功（外部歌词 / 本地 LRC / 纯音乐）

    普通模式（pair_lrc_with_track_dir=False）：
      - MP3 → done_tracks_dir
      - LRC → done_lrc_dir
      - 清理 tracks_dir / lrc_dir 下的空目录

    -d 模式（pair_lrc_with_track_dir=True）：
      - MP3 保持原地不动
      - LRC（如果存在）移动到 MP3 所在目录
      - 不清理目录（避免误删）
    """

    # ⭐ -d 模式：LRC 跟随歌曲目录，歌曲不动
    if config.pair_lrc_with_track_dir:
        target_dir = meta.path.parent

        if lrc_path and lrc_path.exists():
            new_lrc = move_with_dedup(lrc_path, target_dir)
            if new_lrc:
                _log_info(f"[pair-mode] LRC 已移动到歌曲目录：{new_lrc}")
        else:
            _log_info("[pair-mode] 没有 LRC 可移动。")

        # 歌曲文件不动，目录也不清理
        return

    # ⭐ 普通模式：沿用原来的逻辑
    if lrc_path and lrc_path.exists():
        new_lrc = move_with_dedup(lrc_path, config.done_lrc_dir)
        if new_lrc:
            _log_info(f"LRC 已移动到：{new_lrc}")

    if meta.path.exists():
        new_mp3 = move_with_dedup(meta.path, config.done_tracks_dir)
        if new_mp3:
            _log_info(f"MP3 已移动到：{new_mp3}")

    cleanup_empty_dirs(config.tracks_dir)
    cleanup_empty_dirs(config.lrc_dir)


# -------------------- 单曲处理逻辑 --------------------


def process_track(
    config: AppConfig,
    api_client: ApiClient,
    meta: TrackMeta,
    *,
    auto_yes: bool = False,
    dry_run: bool = False,
) -> None:
    """
    按你原来脚本的逻辑，处理一首歌：
      1. /api/get-cached 查内部数据库
      2. /api/get 查外部歌词（可选用）
      3. 本地 LRC（递归匹配）
      4. LRC 解析（删除 credit / 识别纯音乐）
      5. 上传（歌词 / 纯音乐）
      6. 移动文件 & 清理空目录
    """
    _log_info(f"处理：{meta}")

    # 1. 先查内部数据库（不触发外部抓取）
    cached: Optional[LyricsRecord] = api_client.get_cached(meta)
    if cached:
        _log_info("内部数据库已存在歌词 → 自动移动 MP3+LRC 并跳过上传（不再重复提交）")
        _preview("已有 plainLyrics", cached.plain, config.preview_lines)
        _preview("已有 syncedLyrics", cached.synced, config.preview_lines)

        lrc_path = find_lrc_for_track(meta, config, interactive=True)
        _move_after_done(config, meta, lrc_path)
        return

    # 2. 再查外部抓取（仅供参考，可选是否直接使用）
    external: Optional[LyricsRecord] = api_client.get_external(meta)
    if external:
        plain_ext = external.plain
        synced_ext = external.synced
        instrumental_ext = external.instrumental

        _log_info("外部抓取到歌词（仅供参考，可选择是否直接使用外部版本上传）：")
        _preview("外部 plainLyrics", plain_ext, config.preview_lines)
        _preview("外部 syncedLyrics", synced_ext, config.preview_lines)

        if instrumental_ext:
            _log_info("外部记录中该曲被标记为 instrumental（或两种歌词字段均为空）。")

        if dry_run:
            _log_info("[dry-run] 模式下，仅展示外部结果，不上传，也不继续本地处理。")
            return

        use_ext = False
        if auto_yes:
            # 自动模式优先使用外部结果
            use_ext = True
        else:
            choice = input("是否直接使用外部版本上传？[y/N]: ").strip().lower()
            use_ext = choice in ("y", "yes")

        if use_ext:
            if instrumental_ext:
                _log_info("将使用“纯音乐”方式上传（不包含任何歌词内容，只标记为 instrumental）。")
                ok = upload_instrumental(config, meta)
            else:
                _log_info("将直接使用外部 plain+synced 歌词上传。")
                ok = upload_lyrics(config, meta, plain_ext, synced_ext)

            if ok:
                _log_info("外部歌词上传完成 ✓")
                lrc_path = find_lrc_for_track(meta, config, interactive=True)
                _move_after_done(config, meta, lrc_path)
            else:
                _log_error("外部歌词上传失败 ×")
            return
        else:
            _log_info("用户选择不直接使用外部歌词 → 继续尝试本地 LRC。")

    # 3. 查找本地 LRC 文件
    lrc_path = find_lrc_for_track(meta, config, interactive=True)
    if not lrc_path:
        _log_warn(f"⚠ 未找到本地 LRC 文件：{meta.track}")
        if dry_run:
            _log_info("[dry-run] 模式下，未找到 LRC，仅提示，不上传，不标记纯音乐。")
            return

        while True:
            choice = input(
                "未找到本地 LRC，选择 "
                "[s] 跳过该歌曲 / "
                "[i] 上传空歌词标记为纯音乐 / "
                "[q] 退出程序: "
            ).strip().lower()

            if choice == "s":
                _log_info("跳过该歌曲，不上传、不移动。")
                return
            elif choice == "i":
                _log_info("将上传空歌词（标记为纯音乐）。")
                ok = upload_instrumental(config, meta)
                if ok:
                    _log_info("纯音乐标记上传完成 ✓")
                    _move_after_done(config, meta, lrc_path=None)
                else:
                    _log_error("纯音乐标记上传失败 ×")
                return
            elif choice == "q":
                _log_info("用户选择退出程序。")
                sys.exit(1)
            else:
                print("无效输入，请重新选择。")

    # 4. 解析本地 LRC
    parsed: ParsedLRC = parse_lrc_file(lrc_path)

    if parsed.is_instrumental:
        _log_info("LRC 中检测到“纯音乐，请欣赏”等字样，将按纯音乐处理（不上传歌词内容）。")

    _preview("本地 plainLyrics（整理后，将上传）", parsed.plain, config.preview_lines)
    _preview("本地 syncedLyrics（整理后，将上传）", parsed.synced, config.preview_lines)

    if dry_run:
        _log_info("[dry-run] 模式，仅预览 LRC，不上传。")
        return

    # 判断是否按纯音乐上传
    treat_as_instrumental = parsed.is_instrumental or (
        not parsed.plain.strip() and not parsed.synced.strip()
    )

    if treat_as_instrumental:
        _log_info("根据解析结果：将按纯音乐曲目上传。")
        if not auto_yes:
            choice = input("确认以纯音乐方式上传？[y/N]: ").strip().lower()
            if choice not in ("y", "yes"):
                _log_info("用户取消上传。")
                return

        ok = upload_instrumental(config, meta)
        if ok:
            _log_info("纯音乐上传完成 ✓")
            _move_after_done(config, meta, lrc_path)
        else:
            _log_error("纯音乐上传失败 ×")
        return

    # 非纯音乐 → 正常上传 plain+synced
    if not auto_yes:
        choice = input("确认上传本地歌词？[y/N]: ").strip().lower()
        if choice not in ("y", "yes"):
            _log_info("用户取消上传。")
            return

    ok = upload_lyrics(config, meta, parsed.plain, parsed.synced)
    if ok:
        _log_info("上传完成 ✓")
        _move_after_done(config, meta, lrc_path)
    else:
        _log_error("上传失败 ×")


# -------------------- 批量处理 --------------------


def process_all(
    config: AppConfig,
    *,
    auto_yes: bool = False,
    dry_run: bool = False,
    single: Optional[str] = None,
) -> None:
    """
    入口函数，等价于你之前脚本中的 main() 行为：

      - 如果 single 不为空 → 只处理指定文件
      - 否则递归扫描 tracks_dir 下所有 .mp3

    CLI 层只需要调用这一层。
    """
    api_client = ApiClient(config)

    metas: List[TrackMeta] = []

    if single:
        mp3 = config.tracks_dir / single
        if not mp3.is_file():
            _log_error(f"文件不存在：{mp3}")
            return
        tm = TrackMeta.from_mp3(mp3)
        if tm:
            metas.append(tm)
    else:
        for p in sorted(config.tracks_dir.rglob("*.mp3")):
            tm = TrackMeta.from_mp3(p)
            if tm:
                metas.append(tm)

    for meta in metas:
        process_track(
            config,
            api_client,
            meta,
            auto_yes=auto_yes,
            dry_run=dry_run,
        )
        print()

    _log_info("全部完成。")

./__init__.py


===== FILE: ./__init__.py =====

"""
pylrclibup

A tool to upload local LRC lyrics / instrumental markers to LRCLIB.net,
based on track metadata from your music library (e.g. Jellyfin + MusicBrainz Picard).
"""

from .config import AppConfig

__all__ = ["AppConfig"]

__version__ = "0.1.0"
./cli/__init__.py


===== FILE: ./cli/__init__.py =====

from .main import run_cli

__all__ = ["run_cli"]./cli/main.py


===== FILE: ./cli/main.py =====

from __future__ import annotations

import argparse
import sys
from pathlib import Path

from ..config import AppConfig
from ..processor import process_all


def run_cli():
    """
    pylrclibup 的命令行入口点。
    """

    parser = argparse.ArgumentParser(
        prog="pylrclibup",
        description="Upload lyrics or instrumental tags to LRCLIB with local files."
    )

    # 与你原脚本一致
    parser.add_argument("--yes", action="store_true",
                        help="不询问确认，默认选择“上传”或“使用外部歌词”")

    parser.add_argument("--dry-run", action="store_true",
                        help="仅预览，不执行任何上传和移动")

    parser.add_argument("--single", type=str,
                        help="只处理 tracks/ 中指定文件，例如 'foo.mp3'")

    # 新增：可自定义路径
    parser.add_argument("--root", default=".",
                        help="根目录（默认当前目录）")
    parser.add_argument("--tracks", default="tracks",
                        help="mp3 输入目录（相对 root）")
    parser.add_argument("--lrc", default="lrc-files",
                        help="lrc 输入目录（相对 root）")
    parser.add_argument("--done-tracks", default="done-tracks",
                        help="mp3 输出目录（相对 root）")
    parser.add_argument("--done-lrc", default="done-lrc-files",
                        help="lrc 输出目录（相对 root）")

    parser.add_argument("--preview-lines", type=int, default=10,
                        help="预览歌词时显示的行数")

    parser.add_argument(
        "-d",
        "--default",
        nargs=2,
        metavar=("TRACKS_DIR", "LRC_DIR"),
        help=(
            "default 模式：使用指定歌曲目录和歌词目录，完整执行上传流程，"
            "但歌曲文件保持原地不动，匹配和使用过的 LRC 会被移动到对应歌曲文件所在目录。"
        ),
    )


    args = parser.parse_args()

    # ---------- 模式一：-d default 模式 ----------
    if args.default is not None:
        tracks_arg, lrc_arg = args.default

        root = Path(args.root).resolve()

        # 允许传相对路径：相对 root 解析
        tracks_dir = Path(tracks_arg)
        if not tracks_dir.is_absolute():
            tracks_dir = (root / tracks_dir).resolve()

        lrc_dir = Path(lrc_arg)
        if not lrc_dir.is_absolute():
            lrc_dir = (root / lrc_dir).resolve()

        # 提示：-d 模式强制非 dry-run 且必须人工确认
        if args.dry_run or args.yes:
            print("[WARN] -d 模式下会忽略 --dry-run 和 --yes，始终进行真实上传并需要人工确认。")

        # 构建配置：注意这里开启 pair_lrc_with_track_dir
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tracks_dir,
            lrc_dir=lrc_dir,
            done_tracks_dir=root / args.done_tracks,
            done_lrc_dir=root / args.done_lrc,
            preview_lines=args.preview_lines,
            pair_lrc_with_track_dir=True,  # ⭐ 核心
        )

        try:
            # -d 模式：强制 auto_yes=False, dry_run=False
            process_all(
                config,
                auto_yes=False,
                dry_run=False,
                single=args.single,  # 可以照常用 --single
            )
        except KeyboardInterrupt:
            print("\n[INFO] 用户中断执行（Ctrl+C），已优雅退出。")
            sys.exit(0)

        return  # ⭐ 不再执行后面的“普通模式”逻辑

    # ---------- 模式二：普通模式（不带 -d） ----------
    root = Path(args.root).resolve()
    config = AppConfig.from_env_and_defaults(
        tracks_dir=root / args.tracks,
        lrc_dir=root / args.lrc,
        done_tracks_dir=root / args.done_tracks,
        done_lrc_dir=root / args.done_lrc,
        preview_lines=args.preview_lines,
    )

    try:
        process_all(config, auto_yes=args.yes, dry_run=args.dry_run, single=args.single)
    except KeyboardInterrupt:
        print("\n[INFO] 用户中断执行（Ctrl+C），已优雅退出。")
        sys.exit(0)
./lrc/matcher.py


===== FILE: ./lrc/matcher.py =====

from __future__ import annotations

from pathlib import Path
from typing import List, Optional, Tuple

from ..config import AppConfig
from ..model import TrackMeta
from .parser import normalize_name


# -------------------- 艺人拆分 & 匹配 --------------------


def split_artists(s: str) -> List[str]:
    """
    将艺人字符串拆分成多个 artist：
      - 支持 "feat." / "featuring" 作为分隔符
      - 支持 "&"、"和"、"/"、";"、"、"、" x " / " X " / "×"
      - 将各种逗号/间隔统一整理
    """
    import re

    s = s.lower()
    # 1. 先处理 feat/featuring（转为特殊标记，避免被后续替换影响）
    s = re.sub(r'\bfeat\.?\b', '<<<SEP>>>', s)
    s = re.sub(r'\bfeaturing\b', '<<<SEP>>>', s)
    # 2. ⭐ 关键修复：先拆分单独的半角逗号（直接相邻字符，无空格）
    #    使用负向前瞻/后顾确保逗号前后不是空格
    s = re.sub(r'(?<!\s),(?!\s)', '<<<SEP>>>', s)
    
    # 3. 处理其他分隔符（带空格的 x/X/×）
    for sep in [" x ", " X ", "×"]:
        s = s.replace(sep, '<<<SEP>>>')
    
    # 4. 处理常见符号分隔符
    for sep in ["&", "和", "/", ";", "、", "，", "､"]:
        s = s.replace(sep, '<<<SEP>>>')
    # 5. 统一拆分
    artists = [a.strip() for a in s.split('<<<SEP>>>') if a.strip()]
    
    # 去重保持顺序
    return list(dict.fromkeys(artists))


def match_artists(mp3_artists: List[str], lrc_artists: List[str]) -> bool:
    """
    艺人匹配策略：
      - 对双方艺人列表 normalize
      - 只要有任意一个艺人名相等 → 认为匹配成功
    """
    mp3_norm = {normalize_name(a) for a in mp3_artists}
    lrc_norm = {normalize_name(a) for a in lrc_artists}
    return not mp3_norm.isdisjoint(lrc_norm)


# -------------------- LRC 文件名解析 & 匹配 --------------------


def parse_lrc_filename(path: Path) -> Tuple[List[str], str]:
    """
    从 LRC 文件名解析出 (artists_list, title_norm)。

    约定格式为：
      "Artist - Title.lrc"

    例如：
      "A & B - Song.lrc"
    会解析为：
      (["a", "b"], "song")

    注意：这里不对 " - " 做任何过滤，这个分隔符是稳定可靠的。
    """
    stem = path.stem
    if " - " not in stem:
        return [], ""
    artist_raw, title_raw = stem.split(" - ", 1)
    artists = split_artists(artist_raw)
    title = normalize_name(title_raw)
    return artists, title


def find_lrc_for_track(
    meta: TrackMeta,
    config: AppConfig,
    *,
    interactive: bool = True,
) -> Optional[Path]:
    """
    在 config.lrc_dir 下递归寻找和某首歌曲匹配的 LRC 文件。

    匹配规则：
      1. 从 MP3 的 meta.track / meta.artist 获取歌名和艺人
      2. 将歌名 normalize 后，与 LRC 文件名中 parse 出的 title_norm 做完全匹配
      3. 艺人名使用 split_artists 拆分，只要任一艺人 match_artists 成功即视为匹配

    行为：
      - 若无匹配 → 返回 None
      - 若匹配到 1 个 → 直接返回
      - 若匹配到多个且 interactive=True → 让用户选择
      - 若匹配到多个且 interactive=False → 返回第一个匹配的路径
    """
    meta_title_norm = normalize_name(meta.track)
    meta_artists = split_artists(meta.artist)

    candidates: List[Path] = []

    for p in config.lrc_dir.rglob("*.lrc"):
        lrc_artists, lrc_title_norm = parse_lrc_filename(p)
        if not lrc_title_norm:
            continue

        # 1) 歌曲名必须完全相等（在 normalize 之后）
        if lrc_title_norm != meta_title_norm:
            continue

        # 2) 艺人名任意一个成功匹配即可
        if match_artists(meta_artists, lrc_artists):
            candidates.append(p)

    if not candidates:
        return None

    if len(candidates) == 1 or not interactive:
        # 单一匹配 or 非交互模式
        return candidates[0]

    # 多个候选 → 交互选择
    print("\n匹配到多个歌词文件，请选择：")
    for idx, c in enumerate(candidates, 1):
        print(f"{idx}) {c}")

    while True:
        choice = input(f"请输入 1-{len(candidates)}: ").strip()
        if choice.isdigit():
            i = int(choice)
            if 1 <= i <= len(candidates):
                return candidates[i - 1]
        print("输入无效，请重新输入。")

./lrc/__init__.py


===== FILE: ./lrc/__init__.py =====

from .parser import (
    normalize_name,
    ParsedLRC,
    parse_lrc_file,
)

from .matcher import (
    split_artists,
    match_artists,
    parse_lrc_filename,
    find_lrc_for_track,
)

__all__ = [
    "normalize_name",
    "ParsedLRC",
    "parse_lrc_file",
    "split_artists",
    "match_artists",
    "parse_lrc_filename",
    "find_lrc_for_track",
]
./lrc/parser.py


===== FILE: ./lrc/parser.py =====

from __future__ import annotations

import re
import unicodedata
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional


# -------------------- 文本规范化 --------------------


def normalize_name(s: str) -> str:
    """
    增强版规范化：支持多语言
      - 去首尾空白
      - 降为小写
      - 统一西里尔字母变体（如 Ё→Е）
      - Unicode 规范化（NFKC）
      - 替换全角标点
      - 移除零宽字符和控制字符
      - 合并多余空格
    """
    s = s.strip().lower()
    
    # Unicode 规范化
    s = unicodedata.normalize('NFKC', s)
    
    # 西里尔字母映射
    cyrillic_map = {
        'ё': 'е',  # 俄语
        'і': 'и',  # 乌克兰语
        'ї': 'и',
        'є': 'е',
        'ґ': 'г',
    }
    for old, new in cyrillic_map.items():
        s = s.replace(old, new)
    
    # 全角标点替换
    replacements = {
        "（": "(",
        "）": ")",
        "【": "[",
        "】": "]",
        "：": ":",
        "。": ".",
        "，": ",",
        "！": "!",
        "？": "?",
        "＆": "&",
        "／": "/",
        "；": ";",
    }
    for k, v in replacements.items():
        s = s.replace(k, v)
    
    # 移除零宽字符和控制字符（保留空格）
    s = ''.join(ch for ch in s if unicodedata.category(ch)[0] not in ('C', 'Z') or ch == ' ')
    
    # 合并多余空格
    s = re.sub(r"\s+", " ", s)
    return s.strip()


# -------------------- LRC 内容解析 --------------------

# 标准时间标签：[mm:ss.xx] 或 [mm:ss.xxx]
TIMESTAMP_RE = re.compile(
    r"\[\d{2}:\d{2}\.\d{2,3}\]"
)

# 扩展时间标签（支持特殊格式如 [00:00.00-1]）
EXTENDED_TIMESTAMP_RE = re.compile(
    r"\[\d{2}:\d{2}(?:\.\d{1,3}(?:-\d{1,3})?)?\]"
)

# LRC 头部标签，如 [ar:xxx] / [ti:xxx]
HEADER_TAG_RE = re.compile(r"^\[[a-zA-Z]{2,3}:.+\]$")

# NCM 常见 credit 关键字（扩展版）
CREDIT_KEYWORDS = (
    "作词", "作曲", "编曲", "混音", "缩混", "录音", "母带", "制作", "监制", "和声", 
    "配唱", "制作人", "演唱", "伴奏", "编配", "吉他", "贝斯", "鼓", "键盘", "弦乐", 
    "制作团队", "打击乐", "采样", "音效", "人声", "合成器", "录音师", "混音师", "编曲师",
    "出品", "发行", "企划", "统筹", "后期", "音乐总监"
)

# 匹配 credit 行：支持全角/半角冒号
CREDIT_RE = re.compile(
    rf"^({'|'.join(re.escape(k) for k in CREDIT_KEYWORDS)})\s*[:：]\s*.+$"
)

# "纯音乐，请欣赏"类提示关键字
PURE_MUSIC_PHRASES = (
    "纯音乐，请欣赏",
    "纯音乐, 请欣赏",
    "纯音乐 请欣赏",
    "此歌曲为没有填词的纯音乐",
    "instrumental",
)


@dataclass
class ParsedLRC:
    """
    LRC 解析结果：
      - synced: 带时间戳的 LRC 内容（已标准化）
      - plain: 纯文本歌词（不包含时间标签）
      - is_instrumental: 是否检测到"纯音乐"性质
    """
    synced: str
    plain: str
    is_instrumental: bool


def read_text_any(path: Path) -> str:
    """
    尝试多种编码读取文本文件：
      - utf-8-sig（带 BOM）
      - utf-8
      - gb18030（中文）
      - 最后使用 utf-8 并忽略错误
    """
    for enc in ("utf-8-sig", "utf-8", "gb18030"):
        try:
            return path.read_text(encoding=enc)
        except UnicodeDecodeError:
            continue
    return path.read_text(encoding="utf-8", errors="ignore")


def _contains_cjk(text: str) -> bool:
    """
    粗略判断文本是否包含中日韩文字
    使用 Unicode 范围：
      - 中日韩统一表意文字：\u4E00-\u9FFF
      - 中日韩扩展 A：\u3400-\u4DBF
      - 日文假名：\u3040-\u309F, \u30A0-\u30FF
    """
    return bool(re.search(r'[\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF]', text))


def parse_lrc_file(path: Path, *, remove_translations: bool = True) -> ParsedLRC:
    """
    增强版 LRC 解析：
    
    新增功能（来自 lrc-standardizer.sh）：
      1. ⭐ 删除歌词头：跳过第一个标准时间戳之前的所有内容
      2. ⭐ 删除中文翻译行：时间戳相同的连续中文行（可选）
    
    原有功能：
      - 保留 LRC 头部标签（[ar:] [ti:] 等）在 synced 中
      - 删除 NCM credit 行（作词/作曲等）
      - 检测"纯音乐，请欣赏"类提示
      - 支持扩展时间戳格式
    
    Args:
        path: LRC 文件路径
        remove_translations: 是否删除重复时间戳的翻译行（默认 True）
    
    Returns:
        ParsedLRC(synced, plain, is_instrumental)
    """
    raw = read_text_any(path)
    raw = raw.replace("\r\n", "\n").replace("\r", "\n")
    
    synced_lines: List[str] = []
    plain_lines: List[str] = []
    is_instrumental = False
    
    # ⭐ 新增：标记是否已遇到第一个标准时间戳
    started = False
    
    # ⭐ 新增：记录上一行的时间戳（用于检测翻译行）
    prev_timestamp: Optional[str] = None
    
    for line in raw.splitlines():
        s = line.strip()
        
        # ========== 阶段 1: 删除歌词头 ==========
        if not started:
            # 检查是否为标准时间戳行
            if TIMESTAMP_RE.match(s):
                started = True
            else:
                # 跳过第一个时间戳之前的所有内容（包括非标准标签）
                continue
        
        # ========== 阶段 2: 处理已开始的歌词内容 ==========
        
        # 空行：保留到 synced/plain（维持段落结构）
        if not s:
            synced_lines.append("")
            plain_lines.append("")
            prev_timestamp = None  # 重置时间戳记录
            continue
        
        # LRC 头部标签（出现在歌词中间的情况，罕见但存在）
        if HEADER_TAG_RE.match(s):
            synced_lines.append(line)
            prev_timestamp = None
            continue
        
        # 提取时间戳和歌词文本
        timestamp_match = EXTENDED_TIMESTAMP_RE.match(s)
        
        if timestamp_match:
            current_timestamp = timestamp_match.group(0)
            text_no_tag = s[len(current_timestamp):].strip()
            
            # ---------- 检测"纯音乐，请欣赏" ----------
            if text_no_tag and any(p in text_no_tag for p in PURE_MUSIC_PHRASES):
                is_instrumental = True
                prev_timestamp = None
                continue
            
            # ---------- 检测 credit 信息 ----------
            if text_no_tag and CREDIT_RE.match(text_no_tag):
                prev_timestamp = None
                continue
            
            # ⭐ ---------- 检测中文翻译行（新增） ----------
            if remove_translations and prev_timestamp == current_timestamp:
                # 时间戳与上一行相同，检查是否为中文
                if _contains_cjk(text_no_tag):
                    # 跳过这一行（视为翻译）
                    continue
            
            # ---------- 正常歌词行 ----------
            synced_lines.append(line)
            plain_lines.append(text_no_tag)
            prev_timestamp = current_timestamp
        
        else:
            # 无时间戳的行（理论上不应出现在标准 LRC 中）
            # 保留，但不记录时间戳
            synced_lines.append(line)
            if s:
                plain_lines.append(s)
            prev_timestamp = None
    
    # 清理 plain 顶部/尾部的空行
    while plain_lines and not plain_lines[0]:
        plain_lines.pop(0)
    while plain_lines and not plain_lines[-1]:
        plain_lines.pop()
    
    synced = "\n".join(synced_lines)
    plain = "\n".join(plain_lines)
    
    return ParsedLRC(
        synced=synced,
        plain=plain,
        is_instrumental=is_instrumental,
    )
./model/track.py


===== FILE: ./model/track.py =====

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Optional

from mutagen import File as MutaFile
from mutagen.id3 import ID3NoHeaderError

from ..exceptions import PylrclibupError


@dataclass
class TrackMeta:
    """
    表示一首歌曲的元数据（从 MP3 文件读取）：
      - path: MP3 文件路径
      - track: 歌曲名
      - artist: 艺术家名（可能含 feat. 等）
      - album: 专辑名
      - duration: 秒数
    """

    path: Path
    track: str
    artist: str
    album: str
    duration: int  # 秒

    def __str__(self) -> str:
        return f"{self.artist} - {self.track} ({self.album}, {self.duration}s)"

    # --------------------------------------------------

    @staticmethod
    def _get_tag(tags, key: str) -> Optional[str]:
        """从 Mutagen 的 tag 对象中安全获取 text 字段"""
        field = tags.get(key)
        return field.text[0] if field and getattr(field, "text", None) else None

    # --------------------------------------------------

    @classmethod
    def from_mp3(cls, mp3_path: Path) -> Optional["TrackMeta"]:
        """
        从 MP3 文件读取元数据。
        出现异常/标签不完整时返回 None（processor 决定如何处理）。
        """

        try:
            audio = MutaFile(mp3_path)
            if audio is None or audio.tags is None:
                print(f"[WARN] 无法读取标签：{mp3_path.name}")
                return None
        except ID3NoHeaderError:
            print(f"[WARN] 无 ID3 标签：{mp3_path.name}")
            return None
        except Exception as e:
            print(f"[ERROR] 读取标签异常 {mp3_path.name}: {e}")
            return None

        tags = audio.tags

        track = cls._get_tag(tags, "TIT2")
        artist = cls._get_tag(tags, "TPE1")
        album = cls._get_tag(tags, "TALB")

        if not track or not artist or not album:
            print(f"[WARN] 标签不完整：{mp3_path.name}")
            return None

        duration = int(round(getattr(audio.info, "length", 0)))
        if duration <= 0:
            print(f"[WARN] 时长无效：{mp3_path.name}")
            return None

        return cls(
            path=mp3_path,
            track=track,
            artist=artist,
            album=album,
            duration=duration,
        )
./model/lyrics.py


===== FILE: ./model/lyrics.py =====

from __future__ import annotations

from dataclasses import dataclass
from typing import Optional


@dataclass
class LyricsRecord:
    """
    表示从 LRCLIB API（/api/get /api/get-cached 等）获得的歌词记录。
    """

    track_name: str
    artist_name: str
    album_name: str
    duration: int

    plain: str
    synced: str
    instrumental: bool

    @classmethod
    def from_api(cls, data: dict) -> "LyricsRecord":
        plain = data.get("plainLyrics") or ""
        synced = data.get("syncedLyrics") or ""
        instrumental = bool(data.get("instrumental")) or (not plain and not synced)

        return cls(
            track_name=data.get("trackName") or "",
            artist_name=data.get("artistName") or "",
            album_name=data.get("albumName") or "",
            duration=int(data.get("duration", 0)),
            plain=plain,
            synced=synced,
            instrumental=instrumental,
        )
./model/__init__.py


===== FILE: ./model/__init__.py =====

from .track import TrackMeta
from .lyrics import LyricsRecord

__all__ = ["TrackMeta", "LyricsRecord"]
./api/pow.py


===== FILE: ./api/pow.py =====

from __future__ import annotations

import hashlib

from ..exceptions import PoWError


def solve_pow(prefix: str, target_hex: str) -> str:
    """
    按官方说明 + LRCGET 的实现习惯：

    - target 是 16 进制字符串，表示一个 256 位整数阈值
    - 在 nonce 为 0,1,2,... 中寻找第一个满足：
        sha256(prefix + str(nonce)) <= target
    - 返回 nonce 的十进制字符串
    """
    if not prefix or not target_hex:
        raise PoWError(f"无效 PoW 参数：prefix={prefix!r}, target={target_hex!r}")

    target = int(target_hex, 16)

    nonce = 0
    while True:
        token_bytes = (prefix + str(nonce)).encode("utf-8")
        digest = hashlib.sha256(token_bytes).hexdigest()
        if int(digest, 16) <= target:
            print(f"[INFO] Found nonce: {nonce}")
            return str(nonce)
        nonce += 1
./api/client.py


===== FILE: ./api/client.py =====

from __future__ import annotations

from typing import Optional

from ..config import AppConfig
from ..model import TrackMeta, LyricsRecord
from .http import http_request_json
from .publish import (
    upload_lyrics as _upload_lyrics_impl,
    upload_instrumental as _upload_instrumental_impl,
)


def _log_info(msg: str) -> None:
    print(f"[INFO] {msg}")


def _log_warn(msg: str) -> None:
    print(f"[WARN] {msg}")


def _check_duration(meta: TrackMeta, record: dict, label: str) -> None:
    """
    打印 LRCLIB 返回的 duration 与本地 duration 的差值提示。
    逻辑与之前单文件脚本中的实现一致。
    """
    rec_dur = record.get("duration")
    if rec_dur is None:
        return

    try:
        rec_dur_int = int(round(float(rec_dur)))
    except Exception:
        return

    diff = abs(rec_dur_int - meta.duration)
    if diff <= 2:
        _log_info(
            f"{label} 时长检查：LRCLIB={rec_dur_int}s, "
            f"本地={meta.duration}s, 差值={diff}s（<=2s，符合匹配条件）"
        )
    else:
        _log_warn(
            f"{label} 时长检查：LRCLIB={rec_dur_int}s, "
            f"本地={meta.duration}s, 差值={diff}s（>2s，可能不是同一首）"
        )


class ApiClient:
    """
    高层 API 封装：

    - get_cached()  : 调用 /api/get-cached，只查内部数据库
    - get_external(): 调用 /api/get，会触发 LRCLIB 外部抓取
    - upload_lyrics(): 语义化包装 /api/publish（带歌词）
    - upload_instrumental(): 语义化包装 /api/publish（纯音乐）

    说明：
      * 处理时长 ±2 秒的提示逻辑仍与早期脚本一致。
      * HTTP 重试、User-Agent、基地址等逻辑，全部由 AppConfig 控制，
        具体在 http_request_json() 和 publish.py 中实现。
    """

    def __init__(self, config: AppConfig) -> None:
        self.config = config

    # -------- 内部通用 GET 封装 --------

    def _api_get_common(
        self,
        meta: TrackMeta,
        endpoint: str,
        label: str,
    ) -> Optional[LyricsRecord]:
        """
        通用的 /api/get* 调用逻辑：

        - 使用 track / artist / album / duration 构造 query 参数
        - 调用 http_request_json（带自动重试）
        - 如有返回则包装为 LyricsRecord
        """
        params = {
            "track_name": meta.track,
            "artist_name": meta.artist,
            "album_name": meta.album,
            "duration": meta.duration,
        }

        url = f"{self.config.lrclib_base}/{endpoint}"

        data = http_request_json(
            self.config,
            method="GET",
            url=url,
            label=label,
            params=params,
        )
        if not data:
            return None

        _check_duration(meta, data, label)
        return LyricsRecord.from_api(data)

    # -------- 公共方法：GET cached --------

    def get_cached(self, meta: TrackMeta) -> Optional[LyricsRecord]:
        """
        调用 /api/get-cached：
          - 只查 LRCLIB 内部数据库
          - 不触发外部抓取
          - 未命中返回 None
        """
        return self._api_get_common(meta, "get-cached", "内部数据库 (/api/get-cached)")

    # -------- 公共方法：GET external --------

    def get_external(self, meta: TrackMeta) -> Optional[LyricsRecord]:
        """
        调用 /api/get：
          - 若内部没有，会触发 LRCLIB 对外部来源的抓取
          - 未命中返回 None
        """
        return self._api_get_common(meta, "get", "外部抓取 (/api/get)")

    # -------- 公共方法：上传歌词 / 纯音乐（可选给库用户用） --------

    def upload_lyrics(self, meta: TrackMeta, plain: str, synced: str) -> bool:
        """
        高层包装：上传带 plain+synced 的歌词。
        （processor 层目前直接用 publish.upload_lyrics(config, meta, ...)，
         但如果你想在别处以面向对象方式使用，也可以通过 ApiClient 调用。）
        """
        return _upload_lyrics_impl(self.config, meta, plain, synced)

    def upload_instrumental(self, meta: TrackMeta) -> bool:
        """
        高层包装：以“纯音乐”方式上传（不包含任何歌词文本）。
        """
        return _upload_instrumental_impl(self.config, meta)
./api/__init__.py


===== FILE: ./api/__init__.py =====

from .client import ApiClient
from .publish import (
    build_payload_for_publish,
    upload_lyrics,
    upload_instrumental,
)

__all__ = [
    "ApiClient",
    "build_payload_for_publish",
    "upload_lyrics",
    "upload_instrumental",
]
./api/http.py


===== FILE: ./api/http.py =====

from __future__ import annotations

import time
from typing import Optional, Dict, Any

import requests
from requests import RequestException

from ..config import AppConfig


def _log_info(msg: str) -> None:
    print(f"[INFO] {msg}")


def _log_warn(msg: str) -> None:
    print(f"[WARN] {msg}")


def _log_error(msg: str) -> None:
    print(f"[ERROR] {msg}")


def http_request_json(
    config: AppConfig,
    method: str,
    url: str,
    label: str,
    *,
    params: Optional[Dict[str, Any]] = None,
    json_data: Optional[Dict[str, Any]] = None,
    timeout: int = 20,
    max_retries: Optional[int] = None,
    treat_404_as_none: bool = True,
) -> Optional[Dict[str, Any]]:
    """
    封装 GET / POST JSON 请求的通用函数：

    - 遵循 config.max_http_retries 进行重试
    - 对网络异常 / 5xx 做自动重试
    - 404 可选视为 None
    - 其余 4xx 报错后不重试
    """
    retries = max_retries if max_retries is not None else config.max_http_retries

    for attempt in range(1, retries + 1):
        try:
            resp = requests.request(
                method=method,
                url=url,
                params=params,
                json=json_data,
                timeout=timeout,
                headers={"User-Agent": config.user_agent},
            )
        except RequestException as e:
            _log_warn(f"{label} 调用失败（第 {attempt}/{retries} 次自动重试）: {e}")
            if attempt == retries:
                return None
            time.sleep(1)
            continue

        # 特殊处理 404
        if resp.status_code == 404 and treat_404_as_none:
            return None

        if 200 <= resp.status_code < 300:
            try:
                return resp.json()
            except ValueError as e:
                _log_warn(
                    f"{label} 解析 JSON 失败: {e} "
                    f"(status={resp.status_code}, body={resp.text[:200]!r})"
                )
                return None

        # 4xx 默认认为是参数/认证问题，不重试
        if 400 <= resp.status_code < 500:
            _log_warn(
                f"{label} 请求失败：HTTP {resp.status_code}, body={resp.text[:200]!r}"
            )
            return None

        # 5xx → 重试
        _log_warn(
            f"{label} 请求失败：HTTP {resp.status_code}, "
            f"body={resp.text[:200]!r}（第 {attempt}/{retries} 次自动重试）"
        )
        if attempt == retries:
            return None
        time.sleep(1)

    return None
./api/publish.py


===== FILE: ./api/publish.py =====

from __future__ import annotations

import time
from typing import Optional, Dict, Any

import requests
from requests import RequestException

from ..config import AppConfig
from ..exceptions import PublishTokenError
from ..model import TrackMeta
from .http import http_request_json
from .pow import solve_pow


def _log_info(msg: str) -> None:
    print(f"[INFO] {msg}")


def _log_warn(msg: str) -> None:
    print(f"[WARN] {msg}")


def _log_error(msg: str) -> None:
    print(f"[ERROR] {msg}")


# -------------------- Publish Token / PoW --------------------


def request_publish_token(config: AppConfig) -> Optional[str]:
    """
    调用 /api/request-challenge，执行 PoW，返回完整的
      X-Publish-Token = "{prefix}:{nonce}"
    """
    url = f"{config.lrclib_base}/request-challenge"
    data = http_request_json(
        config,
        "POST",
        url,
        "请求发布令牌 (/api/request-challenge)",
        treat_404_as_none=False,
    )
    if not data:
        return None

    prefix = data.get("prefix")
    target = data.get("target")
    if not prefix or not target:
        _log_error(f"请求发布令牌返回异常数据：{data}")
        return None

    try:
        nonce = solve_pow(prefix, target)
    except Exception as e:
        _log_error(f"PoW 求解失败：{e}")
        return None

    return f"{prefix}:{nonce}"


# -------------------- Publish with retry --------------------


def publish_with_retry(
    config: AppConfig,
    meta: TrackMeta,
    payload: Dict[str, Any],
    label: str,
) -> bool:
    """
    对 /api/publish 做一层自动重试：
      - 每次重试都会重新请求 challenge + 重新 PoW
      - 成功（201）即返回 True
      - 4xx 认为是参数或 Token 问题，不重试
    """
    url = f"{config.lrclib_base}/publish"
    retries = config.max_http_retries

    for attempt in range(1, retries + 1):
        token = request_publish_token(config)
        if not token:
            _log_warn(
                f"{label}：获取发布令牌失败（第 {attempt}/{retries} 次自动重试）"
            )
            if attempt == retries:
                return False
            time.sleep(1)
            continue

        headers = {
            "X-Publish-Token": token,
            "Content-Type": "application/json",
            "User-Agent": config.user_agent,
        }

        try:
            resp = requests.post(url, json=payload, headers=headers, timeout=30)
        except RequestException as e:
            _log_warn(
                f"{label} (/api/publish) 调用失败（第 {attempt}/{retries} 次自动重试）: {e}"
            )
            if attempt == retries:
                return False
            time.sleep(1)
            continue

        if resp.status_code == 201:
            return True

        # 4xx: 参数/Token 错误，不再重试
        if 400 <= resp.status_code < 500:
            _log_error(
                f"{label} 失败：HTTP {resp.status_code}, body={resp.text[:200]!r} "
                "（4xx 错误，一般是参数或 Token 问题，不再重试）"
            )
            return False

        # 5xx: 重试
        _log_warn(
            f"{label} 失败：HTTP {resp.status_code}, body={resp.text[:200]!r} "
            f"（第 {attempt}/{retries} 次自动重试）"
        )
        if attempt == retries:
            return False
        time.sleep(1)

    return False


# -------------------- Payload 构造 --------------------


def build_payload_for_publish(
    meta: TrackMeta,
    plain: Optional[str],
    synced: Optional[str],
    *,
    force_instrumental: bool = False,
) -> Dict[str, Any]:
    """
    构造 /api/publish 的 JSON：

    - 若 force_instrumental=True 或 plain/synced 均为空/空白：
        → 不包含 plainLyrics/syncedLyrics 字段
        → 按官方说明：该曲目应被标记为 instrumental
    - 否则：
        → 同时包含 plainLyrics / syncedLyrics
    """
    base: Dict[str, Any] = {
        "trackName": meta.track,
        "artistName": meta.artist,
        "albumName": meta.album,
        "duration": meta.duration,
    }

    if force_instrumental:
        return base

    p = (plain or "").strip()
    s = (synced or "").strip()

    if not p and not s:
        # 两个都确实空 → 也按 instrumental 处理，不附带歌词字段
        return base

    base["plainLyrics"] = p
    base["syncedLyrics"] = s
    return base


# -------------------- 高阶上传函数（给 processor 用） --------------------


def upload_lyrics(
    config: AppConfig,
    meta: TrackMeta,
    plain: str,
    synced: str,
) -> bool:
    payload = build_payload_for_publish(
        meta,
        plain,
        synced,
        force_instrumental=False,
    )
    return publish_with_retry(config, meta, payload, "上传歌词")


def upload_instrumental(
    config: AppConfig,
    meta: TrackMeta,
) -> bool:
    """
    按“纯音乐曲目”上传：
      - 不传任何歌词字段
      - 依赖服务器将其标记为 instrumental
    """
    payload = build_payload_for_publish(
        meta,
        plain=None,
        synced=None,
        force_instrumental=True,
    )
    return publish_with_retry(config, meta, payload, "上传纯音乐标记")
./exceptions.py


===== FILE: ./exceptions.py =====

from __future__ import annotations


class PylrclibupError(Exception):
    """包内自定义异常的基类。"""


class NetworkError(PylrclibupError):
    """表示网络相关错误（如多次重试仍失败）。"""


class PublishTokenError(PylrclibupError):
    """获取或验证发布 Token 失败。"""


class PoWError(PylrclibupError):
    """PoW 求解失败或 challenge 数据异常。"""


class ApiResponseError(PylrclibupError):
    """LRCLIB API 返回了非预期的响应。"""


class LrcNotFoundError(PylrclibupError):
    """为某首歌找不到对应的 LRC 文件。"""


class InstrumentalDetected(PylrclibupError):
    """
    标记解析过程中检测到纯音乐。
    在某些高级用法下，可能希望通过异常来中断普通歌词流程。
    """
./fs/mover.py


===== FILE: ./fs/mover.py =====

from __future__ import annotations

from pathlib import Path


def move_with_dedup(src: Path, dst_dir: Path) -> Path | None:
    """
    将 src 移动到 dst_dir，若同名文件已存在，则自动添加 _dup 后缀。

    返回最终路径；若失败返回 None。
    """
    try:
        dst_dir.mkdir(parents=True, exist_ok=True)
        target = dst_dir / src.name

        # 处理重名情况
        if target.exists():
            stem = target.stem
            suffix = target.suffix
            dedup = 1
            while True:
                candidate = dst_dir / f"{stem}_dup{dedup}{suffix}"
                if not candidate.exists():
                    target = candidate
                    break
                dedup += 1

        src.rename(target)
        return target

    except Exception as e:
        print(f"[WARN] 移动文件失败：{src} → {dst_dir}：{e}")
        return None
./fs/paths.py


===== FILE: ./fs/paths.py =====

from __future__ import annotations

from pathlib import Path
from dataclasses import dataclass

from ..config import AppConfig


@dataclass
class FsPaths:
    """
    根据 AppConfig 构建所有相关路径。

    使用：
        paths = FsPaths.from_config(config)
        paths.tracks_dir
        paths.lrc_dir
        paths.done_tracks_dir
        paths.done_lrc_dir
    """

    root: Path
    tracks_dir: Path
    lrc_dir: Path
    done_tracks_dir: Path
    done_lrc_dir: Path

    @classmethod
    def from_config(cls, config: AppConfig) -> "FsPaths":
        tracks = Path(config.tracks_dir).resolve()
        lrcs = Path(config.lrc_dir).resolve()
        done_tracks = Path(config.done_tracks_dir).resolve()
        done_lrcs = Path(config.done_lrc_dir).resolve()

        # 随便给 root 一个公共前缀（可选）
        root = tracks.parent

        for d in (tracks, lrcs, done_tracks, done_lrcs):
            d.mkdir(parents=True, exist_ok=True)

        return cls(
            root=root,
            tracks_dir=tracks,
            lrc_dir=lrcs,
            done_tracks_dir=done_tracks,
            done_lrc_dir=done_lrcs,
        )
./fs/__init__.py


===== FILE: ./fs/__init__.py =====

from .paths import FsPaths
from .mover import move_with_dedup
from .cleaner import cleanup_empty_dirs

__all__ = [
    "FsPaths",
    "move_with_dedup",
    "cleanup_empty_dirs",
]
./fs/cleaner.py


===== FILE: ./fs/cleaner.py =====

from __future__ import annotations

from pathlib import Path


def cleanup_empty_dirs(root: Path) -> None:
    """
    从 root 开始向下递归删除空目录（保留 root 本身）。
    """

    if not root.exists():
        return

    # 按目录深度从深到浅排序
    dirs = sorted(
        (p for p in root.rglob("*") if p.is_dir()),
        key=lambda p: len(p.parts),
        reverse=True,
    )

    for d in dirs:
        try:
            # if empty
            if not any(d.iterdir()):
                d.rmdir()
        except Exception:
            # 非空或无权限，忽略
            pass
