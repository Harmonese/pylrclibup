./config.py


===== FILE: ./config.py =====

# ===== config.pyï¼ˆæ–°å¢å¸¸é‡ + æ›´æ–°æ³¨é‡Šï¼‰=====

from __future__ import annotations

import os
from dataclasses import dataclass
from pathlib import Path
from typing import Optional


# -------------------- å¸¸é‡ï¼ˆå…¨å±€é…ç½®ï¼‰ --------------------

# LRCLIB API æ ¹åœ°å€
LRCLIB_BASE = "https://lrclib.net/api"

# é¢„è§ˆæ­Œè¯æ—¶æ˜¾ç¤ºçš„æœ€å¤§è¡Œæ•°
PREVIEW_LINES_DEFAULT = 10

# HTTP è°ƒç”¨æœ€å¤§è‡ªåŠ¨é‡è¯•æ¬¡æ•°
MAX_HTTP_RETRIES_DEFAULT = 5

# é»˜è®¤ User-Agent
DEFAULT_USER_AGENT = "pylrclibup (https://github.com/Harmonese/pylrclibup)"

# æ”¯æŒçš„éŸ³é¢‘æ–‡ä»¶æ‰©å±•å
SUPPORTED_AUDIO_EXTENSIONS = {".mp3", ".m4a", ".aac", ".flac", ".wav"}


# -------------------- AppConfig --------------------


@dataclass
class AppConfig:
    """
    å…¨å±€é…ç½®å¯¹è±¡ï¼š

    è·¯å¾„é…ç½®ï¼š
    - tracks_dir: éŸ³é¢‘æ–‡ä»¶è¾“å…¥ç›®å½•
    - lrc_dir: LRC è¾“å…¥ç›®å½•
    - done_tracks_dir: éŸ³é¢‘æ–‡ä»¶è¾“å‡ºç›®å½•ï¼ˆNone = åŸåœ°ä¸åŠ¨ï¼‰
    - done_lrc_dir: LRC è¾“å‡ºç›®å½•ï¼ˆNone = åŸåœ°ä¸åŠ¨æˆ–è·ŸéšéŸ³é¢‘æ–‡ä»¶ï¼‰

    è¡Œä¸ºé…ç½®ï¼ˆä¸‰ä¸ªç‹¬ç«‹çš„å¸ƒå°”æ ‡å¿—ï¼‰ï¼š
    - follow_mp3: LRC æ˜¯å¦è·ŸéšéŸ³é¢‘æ–‡ä»¶åˆ°åŒä¸€ç›®å½•ï¼ˆä¿æŒæ—§åå…¼å®¹æ€§ï¼‰
    - rename_lrc: å¤„ç†åæ˜¯å¦å°† LRC é‡å‘½åä¸ºä¸éŸ³é¢‘æ–‡ä»¶åŒå
    - cleanse_lrc: å¤„ç†å‰æ˜¯å¦æ ‡å‡†åŒ– LRC æ–‡ä»¶

    å…¶ä»–é…ç½®ï¼š
    - preview_lines: é¢„è§ˆæ­Œè¯æ—¶æ˜¾ç¤ºçš„æœ€å¤§è¡Œæ•°
    - max_http_retries: HTTP è‡ªåŠ¨é‡è¯•æ¬¡æ•°
    - user_agent: å‘é€ç»™ LRCLIB çš„ User-Agent
    """

    tracks_dir: Path
    lrc_dir: Path
    done_tracks_dir: Optional[Path]
    done_lrc_dir: Optional[Path]

    follow_mp3: bool = False  # ä¿æŒæ—§åå…¼å®¹æ€§ï¼Œå®é™…å«ä¹‰æ˜¯"è·ŸéšéŸ³é¢‘æ–‡ä»¶"
    rename_lrc: bool = False
    cleanse_lrc: bool = False

    preview_lines: int = PREVIEW_LINES_DEFAULT
    max_http_retries: int = MAX_HTTP_RETRIES_DEFAULT
    user_agent: str = DEFAULT_USER_AGENT

    lrclib_base: str = LRCLIB_BASE

    # -------------------- ä¾¿æ·å±æ€§ï¼ˆå‘åå…¼å®¹ï¼‰ --------------------

    @property
    def pair_lrc_with_track_dir(self) -> bool:
        """å‘åå…¼å®¹ï¼š-d æ¨¡å¼ = follow + rename + cleanse"""
        return self.follow_mp3 and self.rename_lrc and self.cleanse_lrc

    @property
    def match_mode(self) -> bool:
        """å‘åå…¼å®¹ï¼š-m æ¨¡å¼ = follow + rename + cleanse"""
        return self.follow_mp3 and self.rename_lrc and self.cleanse_lrc

    @property
    def keep_in_place(self) -> bool:
        """å‘åå…¼å®¹ï¼šæ˜¯å¦ä¸ºåŸåœ°æ¨¡å¼"""
        return self.done_tracks_dir is None and self.done_lrc_dir is None and not self.follow_mp3

    # -------------------- å·¥å‚æ–¹æ³• --------------------

    @classmethod
    def from_env_and_defaults(
        cls,
        *,
        tracks_dir: Optional[str | Path] = None,
        lrc_dir: Optional[str | Path] = None,
        done_tracks_dir: Optional[str | Path] = None,
        done_lrc_dir: Optional[str | Path] = None,
        follow_mp3: bool = False,
        rename_lrc: bool = False,
        cleanse_lrc: bool = False,
        preview_lines: Optional[int] = None,
        max_http_retries: Optional[int] = None,
        user_agent: Optional[str] = None,
    ) -> "AppConfig":
        """
        ç»Ÿä¸€å…¥å£ï¼šç»¼åˆè€ƒè™‘
        1. æ˜¾å¼ä¼ å…¥ï¼ˆé€šå¸¸æ¥è‡ª CLI å‚æ•°ï¼‰
        2. ç¯å¢ƒå˜é‡
        3. é»˜è®¤å€¼

        ä¼˜å…ˆçº§ï¼šå‚æ•° > ç¯å¢ƒå˜é‡ > é»˜è®¤
        """
        # è§£æè¾“å…¥ç›®å½•
        tracks, lrc = cls._resolve_input_dirs(tracks_dir, lrc_dir)
        
        # è§£æè¾“å‡ºç›®å½•
        done_tracks, done_lrc = cls._resolve_output_dirs(
            done_tracks_dir, done_lrc_dir
        )
        
        # è§£ææ•°å€¼é…ç½®
        preview_lines_val, max_retries_val = cls._resolve_numeric_config(
            preview_lines, max_http_retries
        )
        
        # è§£æ User-Agent
        ua = user_agent or os.getenv("PYLRCLIBUP_USER_AGENT") or DEFAULT_USER_AGENT

        return cls(
            tracks_dir=tracks,
            lrc_dir=lrc,
            done_tracks_dir=done_tracks,
            done_lrc_dir=done_lrc,
            follow_mp3=follow_mp3,
            rename_lrc=rename_lrc,
            cleanse_lrc=cleanse_lrc,
            preview_lines=preview_lines_val,
            max_http_retries=max_retries_val,
            user_agent=ua,
        )

    @staticmethod
    def _resolve_input_dirs(
        tracks_dir: Optional[str | Path],
        lrc_dir: Optional[str | Path],
    ) -> tuple[Path, Path]:
        """è§£æè¾“å…¥ç›®å½•ï¼ˆtracks å’Œ lrcï¼‰"""
        cwd = Path.cwd()
        
        env_tracks = os.getenv("PYLRCLIBUP_TRACKS_DIR")
        env_lrc = os.getenv("PYLRCLIBUP_LRC_DIR")
        
        tracks = Path(tracks_dir or env_tracks or cwd)
        lrc = Path(lrc_dir or env_lrc or cwd)
        
        return tracks, lrc

    @staticmethod
    def _resolve_output_dirs(
        done_tracks_dir: Optional[str | Path],
        done_lrc_dir: Optional[str | Path],
    ) -> tuple[Optional[Path], Optional[Path]]:
        """
        è§£æè¾“å‡ºç›®å½•
        
        è¿”å› None è¡¨ç¤ºåŸåœ°ä¸åŠ¨ï¼ˆæˆ–è·ŸéšéŸ³é¢‘æ–‡ä»¶ï¼Œç”± follow_mp3 å†³å®šï¼‰
        
        Returns:
            (done_tracks, done_lrc)
        """
        env_done_tracks = os.getenv("PYLRCLIBUP_DONE_TRACKS_DIR")
        env_done_lrc = os.getenv("PYLRCLIBUP_DONE_LRC_DIR")
        
        # è®¾ç½® done ç›®å½•ï¼ˆNone è¡¨ç¤ºåŸåœ°ä¸åŠ¨ï¼‰
        done_tracks = None
        if done_tracks_dir:
            done_tracks = Path(done_tracks_dir)
        elif env_done_tracks:
            done_tracks = Path(env_done_tracks)
        
        done_lrc = None
        if done_lrc_dir:
            done_lrc = Path(done_lrc_dir)
        elif env_done_lrc:
            done_lrc = Path(env_done_lrc)
        
        return done_tracks, done_lrc

    @staticmethod
    def _resolve_numeric_config(
        preview_lines: Optional[int],
        max_http_retries: Optional[int],
    ) -> tuple[int, int]:
        """è§£ææ•°å€¼ç±»é…ç½®"""
        # preview_lines
        if preview_lines is None:
            env_preview = os.getenv("PYLRCLIBUP_PREVIEW_LINES")
            if env_preview and env_preview.isdigit():
                preview_lines_val = int(env_preview)
            else:
                preview_lines_val = PREVIEW_LINES_DEFAULT
        else:
            preview_lines_val = preview_lines
        
        # max_http_retries
        if max_http_retries is None:
            env_retries = os.getenv("PYLRCLIBUP_MAX_HTTP_RETRIES")
            if env_retries and env_retries.isdigit():
                max_retries_val = int(env_retries)
            else:
                max_retries_val = MAX_HTTP_RETRIES_DEFAULT
        else:
            max_retries_val = max_http_retries
        
        return preview_lines_val, max_retries_val
./processor/__init__.py


===== FILE: ./processor/__init__.py =====

"""
å¤„ç†å™¨æ¨¡å—ï¼šæ ¸å¿ƒä¸šåŠ¡é€»è¾‘
"""

from .core import process_all, process_track

__all__ = [
    "process_all",
    "process_track",
]
./processor/core.py


===== FILE: ./processor/core.py =====

# ===== processor/core.pyï¼ˆå®Œæ•´ i18n ç‰ˆæœ¬ï¼‰=====

from __future__ import annotations

import sys
from pathlib import Path
from typing import List, Optional

from ..config import AppConfig, SUPPORTED_AUDIO_EXTENSIONS
from ..model import TrackMeta, LyricsRecord
from ..lrc import find_lrc_for_track, parse_lrc_file, cleanse_lrc_file, ParsedLRC
from ..api import ApiClient, upload_lyrics, upload_instrumental
from ..fs import move_with_dedup, cleanup_empty_dirs
from ..logging_utils import log_info, log_warn, log_error
from ..i18n import get_text as _


# -------------------- é¢„è§ˆè¾…åŠ©å‡½æ•° --------------------


def _preview(label: str, text: str, max_lines: int) -> None:
    """é¢„è§ˆæ­Œè¯å†…å®¹"""
    print(f"--- {label} ---")
    if not text:
        print(_("[ç©º]"))
        print("-" * 40)
        return
    lines = text.splitlines()
    for ln in lines[:max_lines]:
        print(ln)
    if len(lines) > max_lines:
        print(_("... å…± {count} è¡Œ").format(count=len(lines)))
    print("-" * 40)


# -------------------- æ–‡ä»¶ç§»åŠ¨é€»è¾‘ --------------------


def move_files_after_processing(
    config: AppConfig,
    meta: TrackMeta,
    lrc_path: Optional[Path],
) -> None:
    """
    å¤„ç†å®Œæˆåç§»åŠ¨æ–‡ä»¶çš„ç»Ÿä¸€é€»è¾‘
    """
    # æ­¥éª¤ 1ï¼šç§»åŠ¨éŸ³é¢‘æ–‡ä»¶
    new_audio_path = meta.path
    
    if config.done_tracks_dir:
        moved_audio = move_with_dedup(meta.path, config.done_tracks_dir)
        if moved_audio:
            new_audio_path = moved_audio
            log_info(_("éŸ³é¢‘æ–‡ä»¶å·²ç§»åŠ¨åˆ°ï¼š{path}").format(path=new_audio_path))
        else:
            log_warn(_("éŸ³é¢‘æ–‡ä»¶ç§»åŠ¨å¤±è´¥ï¼Œå°†ä¿æŒåŸåœ°"))
    
    # å¦‚æœæ²¡æœ‰ LRC æ–‡ä»¶ï¼Œç›´æ¥è¿”å›
    if not lrc_path or not lrc_path.exists():
        cleanup_empty_dirs(config.tracks_dir)
        return
    
    # æ­¥éª¤ 2ï¼šç¡®å®š LRC çš„ç›®æ ‡ç›®å½•
    if config.done_lrc_dir:
        lrc_target_dir = config.done_lrc_dir
    elif config.follow_mp3:
        lrc_target_dir = new_audio_path.parent
    else:
        lrc_target_dir = lrc_path.parent
    
    # æ­¥éª¤ 3ï¼šç¡®å®š LRC çš„ç›®æ ‡æ–‡ä»¶å
    new_lrc_name = None
    if config.rename_lrc:
        new_lrc_name = new_audio_path.stem
    
    # æ­¥éª¤ 4ï¼šåˆ¤æ–­æ˜¯å¦éœ€è¦ç§»åŠ¨
    needs_move = (
        lrc_target_dir != lrc_path.parent or 
        (new_lrc_name and new_lrc_name != lrc_path.stem)
    )
    
    if needs_move:
        new_lrc_path = move_with_dedup(lrc_path, lrc_target_dir, new_name=new_lrc_name)
        if new_lrc_path:
            action = []
            if lrc_target_dir != lrc_path.parent:
                action.append(_("ç§»åŠ¨åˆ° {dir}").format(dir=lrc_target_dir))
            if new_lrc_name and new_lrc_name != lrc_path.stem:
                action.append(_("é‡å‘½åä¸º {name}").format(name=new_lrc_path.name))
            log_info(_("LRC å·²{action}").format(action=_("ã€").join(action)))
        else:
            log_warn(_("LRC ç§»åŠ¨å¤±è´¥"))
    else:
        log_info(_("LRC ä¿æŒåŸåœ°ä¸åŠ¨"))
    
    # æ­¥éª¤ 5ï¼šæ¸…ç†ç©ºç›®å½•
    cleanup_empty_dirs(config.tracks_dir)
    cleanup_empty_dirs(config.lrc_dir)


# -------------------- å•æ›²å¤„ç†è¾…åŠ©å‡½æ•° --------------------


def _handle_cached_lyrics(
    config: AppConfig,
    meta: TrackMeta,
    cached: LyricsRecord,
) -> None:
    """å¤„ç†å†…éƒ¨æ•°æ®åº“å·²æœ‰æ­Œè¯çš„æƒ…å†µ"""
    log_info(_("å†…éƒ¨æ•°æ®åº“å·²å­˜åœ¨æ­Œè¯ â†’ è‡ªåŠ¨ç§»åŠ¨éŸ³é¢‘æ–‡ä»¶+LRC å¹¶è·³è¿‡ä¸Šä¼ ï¼ˆä¸å†é‡å¤æäº¤ï¼‰"))
    _preview(_("å·²æœ‰ plainLyrics"), cached.plain, config.preview_lines)
    _preview(_("å·²æœ‰ syncedLyrics"), cached.synced, config.preview_lines)
    
    lrc_path = find_lrc_for_track(meta, config, interactive=True)
    move_files_after_processing(config, meta, lrc_path)


def _handle_external_lyrics(
    config: AppConfig,
    meta: TrackMeta,
    external: LyricsRecord,
) -> bool:
    """
    å¤„ç†å¤–éƒ¨æŠ“å–åˆ°æ­Œè¯çš„æƒ…å†µ
    
    Returns:
        True è¡¨ç¤ºå·²å¤„ç†å®Œæˆï¼ˆæ— è®ºæˆåŠŸå¤±è´¥ï¼‰ï¼ŒFalse è¡¨ç¤ºç”¨æˆ·é€‰æ‹©ç»§ç»­æœ¬åœ°å¤„ç†
    """
    plain_ext = external.plain
    synced_ext = external.synced
    instrumental_ext = external.instrumental
    
    log_info(_("å¤–éƒ¨æŠ“å–åˆ°æ­Œè¯ï¼ˆä»…ä¾›å‚è€ƒï¼Œå¯é€‰æ‹©æ˜¯å¦ç›´æ¥ä½¿ç”¨å¤–éƒ¨ç‰ˆæœ¬ä¸Šä¼ ï¼‰ï¼š"))
    _preview(_("å¤–éƒ¨ plainLyrics"), plain_ext, config.preview_lines)
    _preview(_("å¤–éƒ¨ syncedLyrics"), synced_ext, config.preview_lines)
    
    if instrumental_ext:
        log_info(_("å¤–éƒ¨è®°å½•ä¸­è¯¥æ›²è¢«æ ‡è®°ä¸º instrumentalï¼ˆæˆ–ä¸¤ç§æ­Œè¯å­—æ®µå‡ä¸ºç©ºï¼‰ã€‚"))
    
    # å§‹ç»ˆè¯¢é—®ç”¨æˆ·
    choice = input(_("æ˜¯å¦ç›´æ¥ä½¿ç”¨å¤–éƒ¨ç‰ˆæœ¬ä¸Šä¼ ï¼Ÿ[y/N]: ")).strip().lower()
    use_ext = choice in ("y", "yes")
    
    if not use_ext:
        log_info(_("ç”¨æˆ·é€‰æ‹©ä¸ç›´æ¥ä½¿ç”¨å¤–éƒ¨æ­Œè¯ â†’ ç»§ç»­å°è¯•æœ¬åœ° LRCã€‚"))
        return False
    
    # æ‰§è¡Œä¸Šä¼ 
    if instrumental_ext:
        log_info(_("å°†ä½¿ç”¨â€œçº¯éŸ³ä¹â€æ–¹å¼ä¸Šä¼ ï¼ˆä¸åŒ…å«ä»»ä½•æ­Œè¯å†…å®¹ï¼Œåªæ ‡è®°ä¸º instrumentalï¼‰ã€‚"))
        ok = upload_instrumental(config, meta)
    else:
        log_info(_("å°†ç›´æ¥ä½¿ç”¨å¤–éƒ¨ plain+synced æ­Œè¯ä¸Šä¼ ã€‚"))
        ok = upload_lyrics(config, meta, plain_ext, synced_ext)
    
    if ok:
        log_info(_("å¤–éƒ¨æ­Œè¯ä¸Šä¼ å®Œæˆ âœ“"))
        lrc_path = find_lrc_for_track(meta, config, interactive=True)
        move_files_after_processing(config, meta, lrc_path)
    else:
        log_error(_("å¤–éƒ¨æ­Œè¯ä¸Šä¼ å¤±è´¥ Ã—"))
    
    return True


def _prompt_for_missing_lrc(
    config: AppConfig,
    meta: TrackMeta,
) -> Optional[Path]:
    """
    å½“æœªæ‰¾åˆ°æœ¬åœ° LRC æ—¶ï¼Œæç¤ºç”¨æˆ·é€‰æ‹©æ“ä½œ
    
    Returns:
        æ‰‹åŠ¨æŒ‡å®šçš„ LRC è·¯å¾„ï¼Œæˆ– Noneï¼ˆè·³è¿‡/é€€å‡º/æ ‡è®°çº¯éŸ³ä¹ï¼‰
    """
    while True:
        choice = input(
            _("æœªæ‰¾åˆ°æœ¬åœ° LRCï¼Œé€‰æ‹© [s] è·³è¿‡è¯¥æ­Œæ›² / [m] æ‰‹åŠ¨æŒ‡å®šæ­Œè¯æ–‡ä»¶ / [i] ä¸Šä¼ ç©ºæ­Œè¯æ ‡è®°ä¸ºçº¯éŸ³ä¹ / [q] é€€å‡ºç¨‹åº: ")
        ).strip().lower()
        
        if choice == "s":
            log_info(_("è·³è¿‡è¯¥æ­Œæ›²ï¼Œä¸ä¸Šä¼ ã€ä¸ç§»åŠ¨ã€‚"))
            return None
        
        elif choice == "m":
            lrc_path = _get_manual_lrc_path()
            if lrc_path:
                return lrc_path
            # è·¯å¾„æ— æ•ˆï¼Œç»§ç»­å¾ªç¯
        
        elif choice == "i":
            log_info(_("å°†ä¸Šä¼ ç©ºæ­Œè¯ï¼ˆæ ‡è®°ä¸ºçº¯éŸ³ä¹ï¼‰ã€‚"))
            ok = upload_instrumental(config, meta)
            if ok:
                log_info(_("çº¯éŸ³ä¹æ ‡è®°ä¸Šä¼ å®Œæˆ âœ“"))
                move_files_after_processing(config, meta, lrc_path=None)
            else:
                log_error(_("çº¯éŸ³ä¹æ ‡è®°ä¸Šä¼ å¤±è´¥ Ã—"))
            return None
        
        elif choice == "q":
            log_info(_("ç”¨æˆ·é€‰æ‹©é€€å‡ºç¨‹åºã€‚"))
            sys.exit(1)
        
        else:
            print(_("æ— æ•ˆè¾“å…¥ï¼Œè¯·é‡æ–°é€‰æ‹©ã€‚"))


def _get_manual_lrc_path() -> Optional[Path]:
    """è·å–ç”¨æˆ·æ‰‹åŠ¨è¾“å…¥çš„ LRC æ–‡ä»¶è·¯å¾„"""
    manual_path_raw = input(_("è¯·è¾“å…¥ LRC æ–‡ä»¶çš„å®Œæ•´è·¯å¾„: ")).strip()
    
    if not manual_path_raw:
        print(_("è·¯å¾„ä¸ºç©ºï¼Œè¯·é‡æ–°é€‰æ‹©ã€‚"))
        return None
    
    # å¤„ç†å¼•å·ï¼ˆå•å¼•å·/åŒå¼•å·ï¼‰
    if (manual_path_raw.startswith("'") and manual_path_raw.endswith("'")) or \
       (manual_path_raw.startswith('"') and manual_path_raw.endswith('"')):
        manual_path_raw = manual_path_raw[1:-1]
    
    # å¤„ç†è·¯å¾„ï¼šæ”¯æŒç»å¯¹è·¯å¾„å’Œç›¸å¯¹è·¯å¾„
    lrc_path = Path(manual_path_raw).expanduser()
    
    if not lrc_path.is_absolute():
        lrc_path = Path.cwd() / lrc_path
    
    lrc_path = lrc_path.resolve()
    
    if not lrc_path.exists() or not lrc_path.is_file():
        print(_("æ–‡ä»¶ä¸å­˜åœ¨æˆ–ä¸æ˜¯æœ‰æ•ˆæ–‡ä»¶ï¼š{path}").format(path=lrc_path))
        return None
    
    if lrc_path.suffix.lower() != ".lrc":
        confirm = input(_("è­¦å‘Šï¼šæ–‡ä»¶æ‰©å±•åä¸æ˜¯ .lrcï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ[y/N]: ")).strip().lower()
        if confirm not in ("y", "yes"):
            return None
    
    log_info(_("ä½¿ç”¨æ‰‹åŠ¨æŒ‡å®šçš„æ­Œè¯æ–‡ä»¶ï¼š{path}").format(path=lrc_path))
    return lrc_path


def _upload_local_lyrics(
    config: AppConfig,
    meta: TrackMeta,
    lrc_path: Path,
    parsed: ParsedLRC,
) -> None:
    """ä¸Šä¼ æœ¬åœ°è§£æçš„æ­Œè¯"""
    treat_as_instrumental = parsed.is_instrumental or (
        not parsed.plain.strip() and not parsed.synced.strip()
    )
    
    if treat_as_instrumental:
        log_info(_("æ ¹æ®è§£æç»“æœï¼šå°†æŒ‰çº¯éŸ³ä¹æ›²ç›®ä¸Šä¼ ã€‚"))
        choice = input(_("ç¡®è®¤ä»¥çº¯éŸ³ä¹æ–¹å¼ä¸Šä¼ ï¼Ÿ[y/N]: ")).strip().lower()
        if choice not in ("y", "yes"):
            log_info(_("ç”¨æˆ·å–æ¶ˆä¸Šä¼ ã€‚"))
            return
        
        ok = upload_instrumental(config, meta)
        if ok:
            log_info(_("çº¯éŸ³ä¹ä¸Šä¼ å®Œæˆ âœ“"))
            move_files_after_processing(config, meta, lrc_path)
        else:
            log_error(_("çº¯éŸ³ä¹ä¸Šä¼ å¤±è´¥ Ã—"))
        return
    
    # éçº¯éŸ³ä¹ â†’ æ­£å¸¸ä¸Šä¼  plain+synced
    choice = input(_("ç¡®è®¤ä¸Šä¼ æœ¬åœ°æ­Œè¯ï¼Ÿ[y/N]: ")).strip().lower()
    if choice not in ("y", "yes"):
        log_info(_("ç”¨æˆ·å–æ¶ˆä¸Šä¼ ã€‚"))
        return
    
    ok = upload_lyrics(config, meta, parsed.plain, parsed.synced)
    if ok:
        log_info(_("ä¸Šä¼ å®Œæˆ âœ“"))
        move_files_after_processing(config, meta, lrc_path)
    else:
        log_error(_("ä¸Šä¼ å¤±è´¥ Ã—"))


# -------------------- å•æ›²å¤„ç†é€»è¾‘ --------------------


def process_track(
    config: AppConfig,
    api_client: ApiClient,
    meta: TrackMeta,
) -> None:
    """
    å¤„ç†ä¸€é¦–æ­Œï¼š
      1. /api/get-cached æŸ¥å†…éƒ¨æ•°æ®åº“
      2. /api/get æŸ¥å¤–éƒ¨æ­Œè¯ï¼ˆå¯é€‰ç”¨ï¼‰
      3. æŸ¥æ‰¾æœ¬åœ° LRC
      4. [å¯é€‰] æ ‡å‡†åŒ– LRCï¼ˆå¦‚æœ config.cleanse_lrc=Trueï¼‰
      5. LRC è§£æ
      6. ä¸Šä¼ ï¼ˆæ­Œè¯ / çº¯éŸ³ä¹ï¼‰
      7. ç§»åŠ¨æ–‡ä»¶ & æ¸…ç†ç©ºç›®å½•
    """
    log_info(_("å¤„ç†ï¼š{meta}").format(meta=meta))

    # 1. å…ˆæŸ¥å†…éƒ¨æ•°æ®åº“ï¼ˆä¸è§¦å‘å¤–éƒ¨æŠ“å–ï¼‰
    cached: Optional[LyricsRecord] = api_client.get_cached(meta)
    if cached:
        _handle_cached_lyrics(config, meta, cached)
        return

    # 2. å†æŸ¥å¤–éƒ¨æŠ“å–ï¼ˆä»…ä¾›å‚è€ƒï¼Œå¯é€‰æ˜¯å¦ç›´æ¥ä½¿ç”¨ï¼‰
    external: Optional[LyricsRecord] = api_client.get_external(meta)
    if external:
        handled = _handle_external_lyrics(config, meta, external)
        if handled:
            return

    # 3. æŸ¥æ‰¾æœ¬åœ° LRC æ–‡ä»¶
    lrc_path = find_lrc_for_track(meta, config, interactive=True)
    
    if not lrc_path:
        log_warn(_("âš  æœªæ‰¾åˆ°æœ¬åœ° LRC æ–‡ä»¶ï¼š{track}").format(track=meta.track))
        lrc_path = _prompt_for_missing_lrc(config, meta)
        if not lrc_path:
            return
    
    # 4. [å¯é€‰] æ ‡å‡†åŒ– LRC æ–‡ä»¶ï¼ˆåœ¨å¤„ç†å¼€å§‹å‰ï¼‰
    if config.cleanse_lrc:
        log_info(_("æ­£åœ¨æ ‡å‡†åŒ– LRC æ–‡ä»¶ï¼š{filename}").format(filename=lrc_path.name))
        if cleanse_lrc_file(lrc_path):
            log_info(_("âœ“ LRC æ–‡ä»¶å·²æ ‡å‡†åŒ–"))
        else:
            log_warn(_("âš  LRC æ–‡ä»¶æ ‡å‡†åŒ–å¤±è´¥ï¼Œå°†ç»§ç»­ä½¿ç”¨åŸå§‹å†…å®¹"))

    # 5. è§£ææœ¬åœ° LRCï¼ˆå·²ç»æ ‡å‡†åŒ–è¿‡äº†ï¼Œç›´æ¥è¯»å–ï¼‰
    parsed: ParsedLRC = parse_lrc_file(lrc_path)

    if parsed.is_instrumental:
        log_info(_("LRC ä¸­æ£€æµ‹åˆ°â€œçº¯éŸ³ä¹ï¼Œè¯·æ¬£èµâ€ç­‰å­—æ ·ï¼Œå°†æŒ‰çº¯éŸ³ä¹å¤„ç†ï¼ˆä¸ä¸Šä¼ æ­Œè¯å†…å®¹ï¼‰ã€‚"))

    _preview(_("æœ¬åœ° plainLyricsï¼ˆå°†ä¸Šä¼ ï¼‰"), parsed.plain, config.preview_lines)
    _preview(_("æœ¬åœ° syncedLyricsï¼ˆå°†ä¸Šä¼ ï¼‰"), parsed.synced, config.preview_lines)

    # 6. ä¸Šä¼ æ­Œè¯
    _upload_local_lyrics(config, meta, lrc_path, parsed)


# -------------------- æ‰¹é‡å¤„ç† --------------------


def process_all(config: AppConfig) -> None:
    """
    å…¥å£å‡½æ•°ï¼šé€’å½’æ‰«æ tracks_dir ä¸‹æ‰€æœ‰æ”¯æŒçš„éŸ³é¢‘æ–‡ä»¶

    CLI å±‚åªéœ€è¦è°ƒç”¨è¿™ä¸€å±‚ã€‚
    """
    api_client = ApiClient(config)

    metas: List[TrackMeta] = []
    
    # æ‰«ææ‰€æœ‰æ”¯æŒçš„éŸ³é¢‘æ ¼å¼
    extensions_str = ", ".join(SUPPORTED_AUDIO_EXTENSIONS)
    log_info(_("æ‰«æéŸ³é¢‘æ–‡ä»¶ï¼š{extensions}").format(extensions=extensions_str))
    
    for ext in SUPPORTED_AUDIO_EXTENSIONS:
        pattern = f"*{ext}"
        for p in sorted(config.tracks_dir.rglob(pattern)):
            tm = TrackMeta.from_audio_file(p)
            if tm:
                metas.append(tm)

    total = len(metas)
    
    if total == 0:
        log_warn(_("æœªæ‰¾åˆ°ä»»ä½•æ”¯æŒçš„éŸ³é¢‘æ–‡ä»¶ï¼ˆ{extensions}ï¼‰").format(extensions=extensions_str))
        return
    
    log_info(_("å…±æ‰¾åˆ° {total} ä¸ªéŸ³é¢‘æ–‡ä»¶").format(total=total))
    
    for idx, meta in enumerate(metas, 1):
        log_info(_("[{idx}/{total}] å¼€å§‹å¤„ç†...").format(idx=idx, total=total))
        process_track(config, api_client, meta)
        print()

    log_info(_("å…¨éƒ¨å®Œæˆã€‚"))
./tests/test_matcher.py


===== FILE: ./tests/test_matcher.py =====

"""
LRC åŒ¹é…å™¨å•å…ƒæµ‹è¯•
"""

import pytest
from pathlib import Path
from pylrclibup.lrc.matcher import (
    split_artists,
    match_artists,
    parse_lrc_filename,
)


class TestSplitArtists:
    """æµ‹è¯• split_artists å‡½æ•°"""
    
    def test_single_artist(self):
        assert split_artists("Artist") == ["artist"]
    
    def test_feat_separator(self):
        result = split_artists("Artist A feat. Artist B")
        assert "artist a" in result
        assert "artist b" in result
    
    def test_featuring_separator(self):
        result = split_artists("Artist A featuring Artist B")
        assert "artist a" in result
        assert "artist b" in result
    
    def test_ampersand_separator(self):
        result = split_artists("Artist A & Artist B")
        assert "artist a" in result
        assert "artist b" in result
    
    def test_chinese_separator(self):
        result = split_artists("è‰ºæœ¯å®¶Aå’Œè‰ºæœ¯å®¶B")
        assert "è‰ºæœ¯å®¶a" in result
        assert "è‰ºæœ¯å®¶b" in result
    
    def test_comma_separator(self):
        result = split_artists("A,B,C")
        assert len(result) == 3
    
    def test_x_separator(self):
        result = split_artists("Artist A x Artist B")
        assert "artist a" in result
        assert "artist b" in result
    
    def test_mixed_separators(self):
        result = split_artists("A & B feat. C / D")
        assert len(result) == 4
    
    def test_dedup(self):
        result = split_artists("A & A & B")
        assert result.count("a") == 1


class TestMatchArtists:
    """æµ‹è¯• match_artists å‡½æ•°"""
    
    def test_exact_match(self):
        assert match_artists(["artist"], ["artist"]) is True
    
    def test_partial_match(self):
        assert match_artists(["a", "b"], ["b", "c"]) is True
    
    def test_no_match(self):
        assert match_artists(["a", "b"], ["c", "d"]) is False
    
    def test_case_insensitive(self):
        assert match_artists(["Artist"], ["ARTIST"]) is True
    
    def test_empty_lists(self):
        assert match_artists([], []) is False
        assert match_artists(["a"], []) is False


class TestParseLrcFilename:
    """æµ‹è¯• parse_lrc_filename å‡½æ•°"""
    
    def test_standard_format(self, tmp_path: Path):
        lrc = tmp_path / "Artist - Song.lrc"
        lrc.touch()
        
        artists, title = parse_lrc_filename(lrc)
        
        assert "artist" in artists
        assert title == "song"
    
    def test_multiple_artists(self, tmp_path: Path):
        lrc = tmp_path / "A & B - Song.lrc"
        lrc.touch()
        
        artists, title = parse_lrc_filename(lrc)
        
        assert "a" in artists
        assert "b" in artists
        assert title == "song"
    
    def test_no_separator(self, tmp_path: Path):
        lrc = tmp_path / "SongWithoutArtist.lrc"
        lrc.touch()
        
        artists, title = parse_lrc_filename(lrc)
        
        assert artists == []
        assert title == ""
    
    def test_multiple_separators(self, tmp_path: Path):
        lrc = tmp_path / "Artist - Song - Remix.lrc"
        lrc.touch()
        
        artists, title = parse_lrc_filename(lrc)
        
        assert "artist" in artists
        assert title == "song - remix"
./tests/conftest.py


===== FILE: ./tests/conftest.py =====

"""
pytest å…±äº« fixtures
"""

import pytest
from pathlib import Path


@pytest.fixture
def sample_lrc_content() -> str:
    """æ ‡å‡† LRC æ–‡ä»¶å†…å®¹æ ·ä¾‹"""
    return """[ti:æµ‹è¯•æ­Œæ›²]
[ar:æµ‹è¯•è‰ºæœ¯å®¶]
[al:æµ‹è¯•ä¸“è¾‘]
[00:00.00]ä½œè¯ï¼šå¼ ä¸‰
[00:01.00]ä½œæ›²ï¼šæå››
[00:02.00]ç¬¬ä¸€è¡Œæ­Œè¯
[00:05.00]ç¬¬äºŒè¡Œæ­Œè¯
[00:10.00]ç¬¬ä¸‰è¡Œæ­Œè¯
"""


@pytest.fixture
def sample_instrumental_lrc() -> str:
    """çº¯éŸ³ä¹ LRC æ ·ä¾‹"""
    return """[00:00.00]çº¯éŸ³ä¹ï¼Œè¯·æ¬£èµ
"""


@pytest.fixture
def sample_lrc_with_translation() -> str:
    """å¸¦ç¿»è¯‘çš„ LRC æ ·ä¾‹"""
    return """[00:00.00]Hello world
[00:00.00]ä½ å¥½ä¸–ç•Œ
[00:05.00]Goodbye
[00:05.00]å†è§
"""


@pytest.fixture
def create_lrc_file(tmp_path: Path):
    """åˆ›å»ºä¸´æ—¶ LRC æ–‡ä»¶çš„å·¥å‚å‡½æ•°"""
    def _create(name: str, content: str) -> Path:
        lrc = tmp_path / name
        lrc.write_text(content, encoding='utf-8')
        return lrc
    return _create
./tests/__init__.py


===== FILE: ./tests/__init__.py =====

"""pylrclibup æµ‹è¯•æ¨¡å—"""
./tests/test_lrc_parser.py


===== FILE: ./tests/test_lrc_parser.py =====

"""
LRC è§£æå™¨å•å…ƒæµ‹è¯•
"""

import pytest
from pathlib import Path
from pylrclibup.lrc.parser import (
    normalize_name,
    parse_lrc_file,
    ParsedLRC,
    TIMESTAMP_RE,
)


class TestNormalizeName:
    """æµ‹è¯• normalize_name å‡½æ•°"""
    
    def test_basic_strip_and_lowercase(self):
        assert normalize_name("  Hello World  ") == "hello world"
    
    def test_fullwidth_punctuation(self):
        assert normalize_name("ï¼ˆæµ‹è¯•ï¼‰") == "(æµ‹è¯•)"
        assert normalize_name("ã€æ ‡é¢˜ã€‘") == "[æ ‡é¢˜]"
        assert normalize_name("æ­Œæ›²ï¼šåç§°") == "æ­Œæ›²:åç§°"
    
    def test_cyrillic_mapping(self):
        assert normalize_name("ĞŸÑ€Ğ¸Ğ²Ñ‘Ñ‚") == "Ğ¿Ñ€Ğ¸Ğ²ĞµÑ‚"
        assert normalize_name("ĞĞ»ĞºĞ°") == "ĞµĞ»ĞºĞ°"
    
    def test_multiple_spaces(self):
        assert normalize_name("hello    world") == "hello world"
    
    def test_empty_string(self):
        assert normalize_name("") == ""
    
    def test_unicode_normalization(self):
        # å…¨è§’å­—æ¯åº”è½¬ä¸ºåŠè§’
        assert normalize_name("ï¼¡ï½‚ï½ƒ") == "abc"


class TestTimestampRegex:
    """æµ‹è¯•æ—¶é—´æˆ³æ­£åˆ™è¡¨è¾¾å¼"""
    
    def test_standard_timestamp(self):
        assert TIMESTAMP_RE.match("[00:00.00]")
        assert TIMESTAMP_RE.match("[01:23.45]")
        assert TIMESTAMP_RE.match("[99:59.999]")
    
    def test_invalid_timestamp(self):
        assert not TIMESTAMP_RE.match("[0:00.00]")
        assert not TIMESTAMP_RE.match("[00:00]")
        assert not TIMESTAMP_RE.match("00:00.00")


class TestParseLrcFile:
    """æµ‹è¯• parse_lrc_file å‡½æ•°"""
    
    def test_instrumental_detection(self, tmp_path: Path):
        lrc = tmp_path / "test.lrc"
        lrc.write_text("[00:00.00]çº¯éŸ³ä¹ï¼Œè¯·æ¬£èµ\n[00:01.00]æ­Œè¯å†…å®¹")
        
        result = parse_lrc_file(lrc)
        
        assert result.is_instrumental is True
        assert "çº¯éŸ³ä¹" not in result.synced
    
    def test_credit_removal(self, tmp_path: Path):
        lrc = tmp_path / "test.lrc"
        lrc.write_text(
            "[00:00.00]ä½œè¯ï¼šå¼ ä¸‰\n"
            "[00:01.00]ä½œæ›²ï¼šæå››\n"
            "[00:02.00]è¿™æ˜¯æ­Œè¯\n"
        )
        
        result = parse_lrc_file(lrc)
        
        assert "ä½œè¯" not in result.synced
        assert "ä½œæ›²" not in result.synced
        assert "è¿™æ˜¯æ­Œè¯" in result.plain
    
    def test_empty_file(self, tmp_path: Path):
        lrc = tmp_path / "empty.lrc"
        lrc.write_text("")
        
        result = parse_lrc_file(lrc)
        
        assert result.synced == ""
        assert result.plain == ""
        assert result.is_instrumental is False
    
    def test_no_timestamp(self, tmp_path: Path):
        lrc = tmp_path / "no_ts.lrc"
        lrc.write_text("è¿™ä¸æ˜¯æœ‰æ•ˆçš„ LRC æ–‡ä»¶")
        
        result = parse_lrc_file(lrc)
        
        assert result.synced == ""
        assert result.plain == ""
    
    def test_header_removal(self, tmp_path: Path):
        lrc = tmp_path / "header.lrc"
        lrc.write_text(
            "[ti:æ­Œæ›²å]\n"
            "[ar:è‰ºæœ¯å®¶]\n"
            "[00:00.00]ç¬¬ä¸€è¡Œæ­Œè¯\n"
            "[00:05.00]ç¬¬äºŒè¡Œæ­Œè¯\n"
        )
        
        result = parse_lrc_file(lrc)
        
        # å¤´éƒ¨æ ‡ç­¾åº”è¢«è·³è¿‡
        assert "[ti:" not in result.synced
        assert "[ar:" not in result.synced
        assert "ç¬¬ä¸€è¡Œæ­Œè¯" in result.plain
    
    def test_translation_removal(self, tmp_path: Path):
        lrc = tmp_path / "trans.lrc"
        lrc.write_text(
            "[00:00.00]Hello world\n"
            "[00:00.00]ä½ å¥½ä¸–ç•Œ\n"
            "[00:05.00]Goodbye\n"
        )
        
        result = parse_lrc_file(lrc, remove_translations=True)
        
        # åŒä¸€æ—¶é—´æˆ³çš„ä¸­æ–‡è¡Œåº”è¢«ç§»é™¤
        assert "Hello world" in result.plain
        assert "ä½ å¥½ä¸–ç•Œ" not in result.plain
        assert "Goodbye" in result.plain
    
    def test_keep_translations(self, tmp_path: Path):
        lrc = tmp_path / "trans.lrc"
        lrc.write_text(
            "[00:00.00]Hello world\n"
            "[00:00.00]ä½ å¥½ä¸–ç•Œ\n"
        )
        
        result = parse_lrc_file(lrc, remove_translations=False)
        
        assert "Hello world" in result.plain
        assert "ä½ å¥½ä¸–ç•Œ" in result.plain
./tests/test_fs.py


===== FILE: ./tests/test_fs.py =====

"""
æ–‡ä»¶ç³»ç»Ÿæ“ä½œå•å…ƒæµ‹è¯•
"""

import pytest
from pathlib import Path
from pylrclibup.fs.mover import move_with_dedup
from pylrclibup.fs.cleaner import cleanup_empty_dirs


class TestMoveWithDedup:
    """æµ‹è¯• move_with_dedup å‡½æ•°"""
    
    def test_basic_move(self, tmp_path: Path):
        src = tmp_path / "src" / "file.txt"
        dst_dir = tmp_path / "dst"
        
        src.parent.mkdir(parents=True)
        src.write_text("content")
        
        result = move_with_dedup(src, dst_dir)
        
        assert result is not None
        assert result.exists()
        assert result.name == "file.txt"
        assert not src.exists()
    
    def test_dedup_on_conflict(self, tmp_path: Path):
        src = tmp_path / "src" / "file.txt"
        dst_dir = tmp_path / "dst"
        existing = dst_dir / "file.txt"
        
        src.parent.mkdir(parents=True)
        dst_dir.mkdir(parents=True)
        src.write_text("new content")
        existing.write_text("existing content")
        
        result = move_with_dedup(src, dst_dir)
        
        assert result is not None
        assert result.name == "file_dup1.txt"
        assert existing.exists()
    
    def test_multiple_dedup(self, tmp_path: Path):
        src = tmp_path / "src" / "file.txt"
        dst_dir = tmp_path / "dst"
        
        src.parent.mkdir(parents=True)
        dst_dir.mkdir(parents=True)
        
        # åˆ›å»ºå·²å­˜åœ¨çš„é‡åæ–‡ä»¶
        (dst_dir / "file.txt").write_text("1")
        (dst_dir / "file_dup1.txt").write_text("2")
        
        src.write_text("new")
        result = move_with_dedup(src, dst_dir)
        
        assert result is not None
        assert result.name == "file_dup2.txt"
    
    def test_rename_on_move(self, tmp_path: Path):
        src = tmp_path / "src" / "original.lrc"
        dst_dir = tmp_path / "dst"
        
        src.parent.mkdir(parents=True)
        src.write_text("lyrics")
        
        result = move_with_dedup(src, dst_dir, new_name="new_name")
        
        assert result is not None
        assert result.name == "new_name.lrc"
    
    def test_same_location_no_op(self, tmp_path: Path):
        file = tmp_path / "file.txt"
        file.write_text("content")
        
        result = move_with_dedup(file, tmp_path)
        
        assert result == file
        assert file.exists()


class TestCleanupEmptyDirs:
    """æµ‹è¯• cleanup_empty_dirs å‡½æ•°"""
    
    def test_remove_empty_dirs(self, tmp_path: Path):
        empty_dir = tmp_path / "a" / "b" / "c"
        empty_dir.mkdir(parents=True)
        
        cleanup_empty_dirs(tmp_path)
        
        assert not (tmp_path / "a").exists()
    
    def test_keep_non_empty_dirs(self, tmp_path: Path):
        non_empty = tmp_path / "a" / "b"
        non_empty.mkdir(parents=True)
        (non_empty / "file.txt").write_text("content")
        
        cleanup_empty_dirs(tmp_path)
        
        assert non_empty.exists()
        assert (non_empty / "file.txt").exists()
    
    def test_keep_root(self, tmp_path: Path):
        cleanup_empty_dirs(tmp_path)
        
        assert tmp_path.exists()
    
    def test_mixed_dirs(self, tmp_path: Path):
        # åˆ›å»ºæ··åˆç»“æ„
        (tmp_path / "empty1" / "empty2").mkdir(parents=True)
        (tmp_path / "nonempty").mkdir(parents=True)
        (tmp_path / "nonempty" / "file.txt").write_text("x")
        
        cleanup_empty_dirs(tmp_path)
        
        assert not (tmp_path / "empty1").exists()
        assert (tmp_path / "nonempty").exists()
./tests/test_config.py


===== FILE: ./tests/test_config.py =====

# ===== tests/test_config.py =====

"""
é…ç½®æ¨¡å—å•å…ƒæµ‹è¯•
"""

import pytest
import os
from pathlib import Path
from pylrclibup.config import AppConfig


class TestAppConfig:
    """æµ‹è¯• AppConfig ç±»"""
    
    def test_default_values(self, tmp_path: Path, monkeypatch):
        # æ¸…é™¤ç¯å¢ƒå˜é‡
        monkeypatch.delenv("PYLRCLIBUP_TRACKS_DIR", raising=False)
        monkeypatch.delenv("PYLRCLIBUP_LRC_DIR", raising=False)
        monkeypatch.delenv("PYLRCLIBUP_DONE_TRACKS_DIR", raising=False)
        monkeypatch.delenv("PYLRCLIBUP_DONE_LRC_DIR", raising=False)
        
        monkeypatch.chdir(tmp_path)
        
        config = AppConfig.from_env_and_defaults()
        
        assert config.tracks_dir == tmp_path
        assert config.lrc_dir == tmp_path
        assert config.done_tracks_dir is None
        assert config.done_lrc_dir is None
        assert config.follow_mp3 is False
        assert config.rename_lrc is False
        assert config.cleanse_lrc is False
        assert config.preview_lines == 10
        assert config.max_http_retries == 5
    
    def test_explicit_dirs(self, tmp_path: Path):
        tracks = tmp_path / "tracks"
        lrc = tmp_path / "lrc"
        done_tracks = tmp_path / "done_tracks"
        done_lrc = tmp_path / "done_lrc"
        
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tracks,
            lrc_dir=lrc,
            done_tracks_dir=done_tracks,
            done_lrc_dir=done_lrc,
        )
        
        assert config.tracks_dir == tracks
        assert config.lrc_dir == lrc
        assert config.done_tracks_dir == done_tracks
        assert config.done_lrc_dir == done_lrc
    
    def test_follow_mode(self, tmp_path: Path):
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            follow_mp3=True,
        )
        
        assert config.follow_mp3 is True
    
    def test_rename_mode(self, tmp_path: Path):
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            rename_lrc=True,
        )
        
        assert config.rename_lrc is True
    
    def test_cleanse_mode(self, tmp_path: Path):
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            cleanse_lrc=True,
        )
        
        assert config.cleanse_lrc is True
    
    def test_combined_modes(self, tmp_path: Path):
        # æµ‹è¯• -d æ¨¡å¼ï¼ˆfollow + rename + cleanseï¼‰
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            follow_mp3=True,
            rename_lrc=True,
            cleanse_lrc=True,
        )
        
        assert config.follow_mp3 is True
        assert config.rename_lrc is True
        assert config.cleanse_lrc is True
    
    def test_backward_compatibility_pair_mode(self, tmp_path: Path):
        # -d æ¨¡å¼çš„å‘åå…¼å®¹å±æ€§
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            follow_mp3=True,
            rename_lrc=True,
            cleanse_lrc=True,
        )
        
        assert config.pair_lrc_with_track_dir is True
    
    def test_backward_compatibility_match_mode(self, tmp_path: Path):
        # -m æ¨¡å¼çš„å‘åå…¼å®¹å±æ€§
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            follow_mp3=True,
            rename_lrc=True,
            cleanse_lrc=True,
        )
        
        assert config.match_mode is True
    
    def test_backward_compatibility_keep_in_place(self, tmp_path: Path):
        # åŸåœ°æ¨¡å¼çš„å‘åå…¼å®¹å±æ€§
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
        )
        
        assert config.keep_in_place is True
    
    def test_env_override(self, tmp_path: Path, monkeypatch):
        env_tracks = tmp_path / "env_tracks"
        monkeypatch.setenv("PYLRCLIBUP_TRACKS_DIR", str(env_tracks))
        
        config = AppConfig.from_env_and_defaults()
        
        assert config.tracks_dir == env_tracks
    
    def test_explicit_overrides_env(self, tmp_path: Path, monkeypatch):
        env_tracks = tmp_path / "env_tracks"
        explicit_tracks = tmp_path / "explicit_tracks"
        
        monkeypatch.setenv("PYLRCLIBUP_TRACKS_DIR", str(env_tracks))
        
        config = AppConfig.from_env_and_defaults(tracks_dir=explicit_tracks)
        
        assert config.tracks_dir == explicit_tracks
./tests/test_track.py


===== FILE: ./tests/test_track.py =====

# ===== tests/test_track.pyï¼ˆå®Œæ•´ä¿®å¤ç‰ˆæœ¬ï¼‰=====

"""
TrackMeta å¤šæ ¼å¼æ”¯æŒæµ‹è¯•
"""

import pytest
from pathlib import Path
from unittest.mock import Mock, patch
from pylrclibup.model import TrackMeta


class TestTrackMetaMultiFormat:
    """æµ‹è¯•å¤šæ ¼å¼éŸ³é¢‘æ–‡ä»¶æ”¯æŒ"""
    
    @patch('pylrclibup.model.track.MutaFile')
    def test_mp3_format(self, mock_muta, tmp_path: Path):
        """æµ‹è¯• MP3 æ ¼å¼ï¼ˆID3v2 æ ‡ç­¾ï¼‰"""
        audio_file = tmp_path / "test.mp3"
        audio_file.touch()
        
        # æ¨¡æ‹Ÿ MP3 æ ‡ç­¾ç»“æ„
        mock_audio = Mock()
        mock_audio.tags = {
            "TIT2": Mock(text=["Test Song"]),
            "TPE1": Mock(text=["Test Artist"]),
            "TALB": Mock(text=["Test Album"]),
        }
        # âœ… ä½¿ç”¨ 180.6 é¿å…é“¶è¡Œå®¶èˆå…¥çš„è¾¹ç•Œæƒ…å†µ
        mock_audio.info = Mock(length=180.6)
        mock_muta.return_value = mock_audio
        
        result = TrackMeta.from_audio_file(audio_file)
        
        assert result is not None
        assert result.track == "Test Song"
        assert result.artist == "Test Artist"
        assert result.album == "Test Album"
        assert result.duration == 181
    
    @patch('pylrclibup.model.track.MutaFile')
    def test_m4a_format(self, mock_muta, tmp_path: Path):
        """æµ‹è¯• M4A æ ¼å¼ï¼ˆiTunes MP4 æ ‡ç­¾ï¼‰"""
        audio_file = tmp_path / "test.m4a"
        audio_file.touch()
        
        # æ¨¡æ‹Ÿ M4A æ ‡ç­¾ç»“æ„
        mock_audio = Mock()
        mock_audio.tags = {
            "Â©nam": ["M4A Song"],
            "Â©ART": ["M4A Artist"],
            "Â©alb": ["M4A Album"],
        }
        mock_audio.info = Mock(length=200.0)
        mock_muta.return_value = mock_audio
        
        result = TrackMeta.from_audio_file(audio_file)
        
        assert result is not None
        assert result.track == "M4A Song"
        assert result.artist == "M4A Artist"
        assert result.album == "M4A Album"
        assert result.duration == 200
    
    @patch('pylrclibup.model.track.MutaFile')
    def test_flac_format(self, mock_muta, tmp_path: Path):
        """æµ‹è¯• FLAC æ ¼å¼ï¼ˆVorbis Commentsï¼‰"""
        audio_file = tmp_path / "test.flac"
        audio_file.touch()
        
        # æ¨¡æ‹Ÿ FLAC æ ‡ç­¾ç»“æ„
        mock_audio = Mock()
        mock_audio.tags = {
            "TITLE": ["FLAC Song"],
            "ARTIST": ["FLAC Artist"],
            "ALBUM": ["FLAC Album"],
        }
        mock_audio.info = Mock(length=250.3)
        mock_muta.return_value = mock_audio
        
        result = TrackMeta.from_audio_file(audio_file)
        
        assert result is not None
        assert result.track == "FLAC Song"
        assert result.artist == "FLAC Artist"
        assert result.album == "FLAC Album"
        assert result.duration == 250
    
    @patch('pylrclibup.model.track.MutaFile')
    def test_missing_tags(self, mock_muta, tmp_path: Path):
        """æµ‹è¯•æ ‡ç­¾ä¸å®Œæ•´çš„æƒ…å†µ"""
        audio_file = tmp_path / "incomplete.mp3"
        audio_file.touch()
        
        mock_audio = Mock()
        mock_audio.tags = {
            "TIT2": Mock(text=["Only Title"]),
            # ç¼ºå°‘ artist å’Œ album
        }
        mock_audio.info = Mock(length=100.0)
        mock_muta.return_value = mock_audio
        
        result = TrackMeta.from_audio_file(audio_file)
        
        assert result is None
    
    @patch('pylrclibup.model.track.MutaFile')
    def test_invalid_duration(self, mock_muta, tmp_path: Path):
        """æµ‹è¯•æ— æ•ˆæ—¶é•¿"""
        audio_file = tmp_path / "invalid.mp3"
        audio_file.touch()
        
        mock_audio = Mock()
        mock_audio.tags = {
            "TIT2": Mock(text=["Song"]),
            "TPE1": Mock(text=["Artist"]),
            "TALB": Mock(text=["Album"]),
        }
        mock_audio.info = Mock(length=0)  # æ— æ•ˆæ—¶é•¿
        mock_muta.return_value = mock_audio
        
        result = TrackMeta.from_audio_file(audio_file)
        
        assert result is None
    
    def test_from_mp3_backward_compatibility(self, tmp_path: Path):
        """æµ‹è¯• from_mp3() å‘åå…¼å®¹æ€§"""
        with patch('pylrclibup.model.track.TrackMeta.from_audio_file') as mock_from_audio:
            mock_from_audio.return_value = Mock()
            
            audio_file = tmp_path / "test.mp3"
            audio_file.touch()
            
            result = TrackMeta.from_mp3(audio_file)
            
            mock_from_audio.assert_called_once_with(audio_file)
./__init__.py


===== FILE: ./__init__.py =====

# ===== pylrclibup/__init__.py =====

"""
pylrclibup

A tool to upload local LRC lyrics / instrumental markers to LRCLIB.net,
based on track metadata from your music library (e.g. Jellyfin + MusicBrainz Picard).
"""

from .config import AppConfig
from .logging_utils import get_logger, set_log_level, log_info, log_warn, log_error
from .i18n import setup_i18n, get_text as _  # æ–°å¢

__all__ = [
    "AppConfig",
    "get_logger",
    "set_log_level",
    "log_info",
    "log_warn",
    "log_error",
    "setup_i18n",  # æ–°å¢
    "_",            # æ–°å¢
]

__version__ = "0.3.0"

# é»˜è®¤åˆå§‹åŒ– i18nï¼ˆè‡ªåŠ¨æ£€æµ‹è¯­è¨€ï¼‰
setup_i18n()
./cli/__init__.py


===== FILE: ./cli/__init__.py =====

"""
CLI æ¨¡å—
"""

from .main import run_cli

__all__ = ["run_cli"]
./cli/main.py


===== FILE: ./cli/main.py =====

# ===== pylrclibup/cli/main.pyï¼ˆå®Œæ•´ä¿®å¤ç‰ˆï¼‰=====

from __future__ import annotations

import argparse
import sys
from pathlib import Path

from ..config import AppConfig
from ..processor import process_all
from ..logging_utils import log_info, log_error
from ..i18n import setup_i18n, get_text as _


def _detect_lang_from_argv() -> str:
    """
    ä»å‘½ä»¤è¡Œå‚æ•°ä¸­æå‰æ£€æµ‹ --lang å‚æ•°
    
    åœ¨åˆ›å»º ArgumentParser ä¹‹å‰è°ƒç”¨ï¼Œä»¥ä¾¿æ­£ç¡®æ˜¾ç¤ºå¤šè¯­è¨€ help
    """
    args = sys.argv[1:]
    
    # æ£€æŸ¥ --lang æˆ– --language
    for i, arg in enumerate(args):
        if arg in ('--lang', '--language'):
            if i + 1 < len(args):
                return args[i + 1]
        elif arg.startswith('--lang='):
            return arg.split('=', 1)[1]
        elif arg.startswith('--language='):
            return arg.split('=', 1)[1]
    
    # æœªæŒ‡å®šï¼Œè¿”å› 'auto'
    return 'auto'


def validate_args(args) -> None:
    """éªŒè¯å‘½ä»¤è¡Œå‚æ•°çš„å†²çªè§„åˆ™"""
    # è§„åˆ™ 1ï¼š--follow ä¸ --done-lrc å†²çª
    if args.follow and args.done_lrc:
        log_error(_("é”™è¯¯ï¼š--follow ä¸ --done-lrc ä¸èƒ½åŒæ—¶ä½¿ç”¨"))
        log_error(_("æç¤ºï¼š--follow è¡¨ç¤º LRC è·ŸéšéŸ³é¢‘æ–‡ä»¶ï¼Œä¸åº”æŒ‡å®šç‹¬ç«‹çš„ LRC è¾“å‡ºç›®å½•"))
        sys.exit(1)
    
    # è§„åˆ™ 2ï¼š-d ä¸ -m å†²çª
    if args.default and args.match:
        log_error(_("é”™è¯¯ï¼š-d/--default ä¸ -m/--match ä¸èƒ½åŒæ—¶ä½¿ç”¨"))
        sys.exit(1)
    
    # è§„åˆ™ 3 & 4ï¼šå¿«æ·æ¨¡å¼ä¸å…¶ä»–å‚æ•°å†²çª
    if args.default:
        conflicts = []
        if args.follow:
            conflicts.append("-f/--follow")
        if args.rename:
            conflicts.append("-r/--rename")
        if args.cleanse:
            conflicts.append("-c/--cleanse")
        if args.tracks or args.lrc or args.done_tracks or args.done_lrc:
            conflicts.append(_("è·¯å¾„å‚æ•°"))
        
        if conflicts:
            log_error(_("é”™è¯¯ï¼š-d/--default æ¨¡å¼ä¸èƒ½ä¸ä»¥ä¸‹å‚æ•°åŒæ—¶ä½¿ç”¨ï¼š{conflicts}").format(
                conflicts=', '.join(conflicts)
            ))
            sys.exit(1)
    
    if args.match:
        conflicts = []
        if args.follow:
            conflicts.append("-f/--follow")
        if args.rename:
            conflicts.append("-r/--rename")
        if args.cleanse:
            conflicts.append("-c/--cleanse")
        
        if conflicts:
            log_error(_("é”™è¯¯ï¼š-m/--match æ¨¡å¼ä¸èƒ½ä¸ä»¥ä¸‹å‚æ•°åŒæ—¶ä½¿ç”¨ï¼š{conflicts}").format(
                conflicts=', '.join(conflicts)
            ))
            sys.exit(1)


def run_cli():
    """
    pylrclibup çš„å‘½ä»¤è¡Œå…¥å£ç‚¹ã€‚
    """
    
    # ========== ğŸŒ æå‰åˆå§‹åŒ– i18n ==========
    detected_lang = _detect_lang_from_argv()
    if detected_lang != 'auto':
        setup_i18n(locale=detected_lang)
    else:
        setup_i18n()  # è‡ªåŠ¨æ£€æµ‹ç³»ç»Ÿè¯­è¨€
    
    # ========== åˆ›å»º ArgumentParser ==========
    parser = argparse.ArgumentParser(
        prog="pylrclibup",
        description=_("å°†æœ¬åœ°æ­Œè¯æ–‡ä»¶æˆ–çº¯éŸ³ä¹æ ‡è®°ä¸Šä¼ åˆ° LRCLIBã€‚")
    )

    # -------------------- è·¯å¾„å‚æ•° --------------------
    parser.add_argument(
        "--tracks",
        type=str,
        help=_("éŸ³é¢‘æ–‡ä»¶è¾“å…¥ç›®å½•ï¼ˆé»˜è®¤ï¼šå½“å‰å·¥ä½œç›®å½•ï¼‰")
    )
    parser.add_argument(
        "--lrc",
        type=str,
        help=_("LRC æ–‡ä»¶è¾“å…¥ç›®å½•ï¼ˆé»˜è®¤ï¼šå½“å‰å·¥ä½œç›®å½•ï¼‰")
    )
    parser.add_argument(
        "--done-tracks",
        type=str,
        help=_("å¤„ç†åéŸ³é¢‘æ–‡ä»¶ç§»åŠ¨åˆ°çš„ç›®å½•ï¼ˆé»˜è®¤ï¼šåŸåœ°ä¸åŠ¨ï¼‰")
    )
    parser.add_argument(
        "--done-lrc",
        type=str,
        help=_("å¤„ç†å LRC æ–‡ä»¶ç§»åŠ¨åˆ°çš„ç›®å½•ï¼ˆé»˜è®¤ï¼šåŸåœ°ä¸åŠ¨/è·ŸéšéŸ³é¢‘ï¼Œå–å†³äº --follow è®¾ç½®ï¼‰")
    )

    # -------------------- è¡Œä¸ºæ§åˆ¶å‚æ•° --------------------
    parser.add_argument(
        "-f", "--follow",
        action="store_true",
        help=_("LRC æ–‡ä»¶è·ŸéšéŸ³é¢‘æ–‡ä»¶åˆ°åŒä¸€ç›®å½•ï¼ˆä¸ --done-lrc å†²çªï¼‰")
    )
    parser.add_argument(
        "-r", "--rename",
        action="store_true",
        help=_("å¤„ç†åå°† LRC é‡å‘½åä¸ºä¸éŸ³é¢‘æ–‡ä»¶åŒå")
    )
    parser.add_argument(
        "-c", "--cleanse",
        action="store_true",
        help=_("å¤„ç†å‰æ ‡å‡†åŒ– LRC æ–‡ä»¶ï¼ˆç§»é™¤åˆ¶ä½œä¿¡æ¯ã€ç¿»è¯‘ç­‰ï¼‰")
    )

    # -------------------- å…¶ä»–å‚æ•° --------------------
    parser.add_argument(
        "--preview-lines",
        type=int,
        default=10,
        help=_("é¢„è§ˆæ­Œè¯æ—¶æ˜¾ç¤ºçš„è¡Œæ•°")
    )

    # -------------------- å¿«æ·æ¨¡å¼ --------------------
    parser.add_argument(
        "-d", "--default",
        nargs=2,
        metavar=("TRACKS_DIR", "LRC_DIR"),
        help=_(
            "å¿«æ·æ¨¡å¼ï¼šç­‰ä»·äº --tracks TRACKS_DIR --lrc LRC_DIR --follow --rename --cleanseã€‚"
            "éŸ³é¢‘æ–‡ä»¶ä¿æŒåŸåœ°ä¸åŠ¨ï¼ŒLRC ç§»åŠ¨åˆ°éŸ³é¢‘ç›®å½•å¹¶é‡å‘½åï¼Œä¸”ä¼šæ ‡å‡†åŒ– LRC æ–‡ä»¶ã€‚"
        ),
    )

    parser.add_argument(
        "-m", "--match",
        action="store_true",
        help=_(
            "åŒ¹é…æ¨¡å¼ï¼šç­‰ä»·äº --follow --rename --cleanseã€‚"
            "å¤„ç†å®Œæˆåï¼ŒLRC ç§»åŠ¨åˆ°éŸ³é¢‘ç›®å½•å¹¶é‡å‘½åä¸ºä¸éŸ³é¢‘æ–‡ä»¶ç›¸åŒçš„åç§°ï¼Œä¸”ä¼šæ ‡å‡†åŒ– LRC æ–‡ä»¶ã€‚"
        ),
    )

    # -------------------- è¯­è¨€é€‰é¡¹ --------------------
    parser.add_argument(
        "--lang", "--language",
        type=str,
        choices=["zh_CN", "en_US", "auto"],
        default="auto",
        help=_("ç•Œé¢è¯­è¨€ï¼šzh_CNï¼ˆç®€ä½“ä¸­æ–‡ï¼‰/ en_USï¼ˆEnglishï¼‰/ autoï¼ˆè‡ªåŠ¨æ£€æµ‹ï¼‰"),
    )

    args = parser.parse_args()

    # ========== å‚æ•°å†²çªæ£€æŸ¥ ==========
    validate_args(args)

    # ========== ç»Ÿä¸€å¤„ç†æ‰€æœ‰æ¨¡å¼ ==========
    
    # å¤„ç† -d/--default æ¨¡å¼
    if args.default:
        tracks_arg, lrc_arg = args.default
        
        tracks_dir = Path(tracks_arg).resolve()
        lrc_dir = Path(lrc_arg).resolve()
        done_tracks_dir = None
        done_lrc_dir = None
        follow_mp3 = True
        rename_lrc = True
        cleanse_lrc = True
    
    # å¤„ç† -m/--match æ¨¡å¼
    elif args.match:
        tracks_dir = Path(args.tracks).resolve() if args.tracks else None
        lrc_dir = Path(args.lrc).resolve() if args.lrc else None
        done_tracks_dir = Path(args.done_tracks).resolve() if args.done_tracks else None
        done_lrc_dir = None
        follow_mp3 = True
        rename_lrc = True
        cleanse_lrc = True
    
    # æ™®é€šæ¨¡å¼
    else:
        tracks_dir = Path(args.tracks).resolve() if args.tracks else None
        lrc_dir = Path(args.lrc).resolve() if args.lrc else None
        done_tracks_dir = Path(args.done_tracks).resolve() if args.done_tracks else None
        done_lrc_dir = Path(args.done_lrc).resolve() if args.done_lrc else None
        follow_mp3 = args.follow
        rename_lrc = args.rename
        cleanse_lrc = args.cleanse

    # åˆ›å»ºé…ç½®
    config = AppConfig.from_env_and_defaults(
        tracks_dir=tracks_dir,
        lrc_dir=lrc_dir,
        done_tracks_dir=done_tracks_dir,
        done_lrc_dir=done_lrc_dir,
        follow_mp3=follow_mp3,
        rename_lrc=rename_lrc,
        cleanse_lrc=cleanse_lrc,
        preview_lines=args.preview_lines,
    )

    # æ‰§è¡Œå¤„ç†
    try:
        process_all(config)
    except KeyboardInterrupt:
        print("\n" + _("[ä¿¡æ¯] ç”¨æˆ·ä¸­æ–­æ‰§è¡Œï¼ˆCtrl+Cï¼‰ï¼Œå·²ä¼˜é›…é€€å‡ºã€‚"))
        sys.exit(0)
./lrc/matcher.py


===== FILE: ./lrc/matcher.py =====

# ===== lrc/matcher.pyï¼ˆå®Œæ•´ i18n ç‰ˆæœ¬ï¼‰=====

from __future__ import annotations

from pathlib import Path
from typing import List, Optional, Tuple
import re

from ..config import AppConfig
from ..model import TrackMeta
from ..i18n import get_text as _
from .parser import normalize_name


# -------------------- è‰ºäººæ‹†åˆ† & åŒ¹é… --------------------


def split_artists(s: str) -> List[str]:
    """
    å°†è‰ºäººå­—ç¬¦ä¸²æ‹†åˆ†æˆå¤šä¸ª artist
    """
    s = s.lower()
    
    # å¤„ç† feat/featuring
    s = re.sub(r'\bfeat\.?\s+', '<<<SEP>>>', s)
    s = re.sub(r'\bfeaturing\b', '<<<SEP>>>', s)
    
    # æ‹†åˆ†åŠè§’é€—å·
    s = re.sub(r'(?<!\s),(?!\s)', '<<<SEP>>>', s)
    
    # å¤„ç†å…¶ä»–åˆ†éš”ç¬¦
    for sep in [" x ", " X ", "Ã—"]:
        s = s.replace(sep, '<<<SEP>>>')
    
    for sep in ["&", "å’Œ", "/", ";", "ã€", "ï¼Œ", "ï½¤"]:
        s = s.replace(sep, '<<<SEP>>>')
    
    artists = [a.strip() for a in s.split('<<<SEP>>>') if a.strip()]
    
    return list(dict.fromkeys(artists))


def match_artists(mp3_artists: List[str], lrc_artists: List[str]) -> bool:
    """è‰ºäººåŒ¹é…ç­–ç•¥"""
    mp3_norm = {normalize_name(a) for a in mp3_artists}
    lrc_norm = {normalize_name(a) for a in lrc_artists}
    return not mp3_norm.isdisjoint(lrc_norm)


# -------------------- LRC æ–‡ä»¶åè§£æ & åŒ¹é… --------------------


def parse_lrc_filename(path: Path) -> Tuple[List[str], str]:
    """ä» LRC æ–‡ä»¶åè§£æå‡º (artists_list, title_norm)"""
    stem = path.stem
    if " - " not in stem:
        return [], ""
    artist_raw, title_raw = stem.split(" - ", 1)
    artists = split_artists(artist_raw)
    title = normalize_name(title_raw)
    return artists, title


def find_lrc_for_track(
    meta: TrackMeta,
    config: AppConfig,
    *,
    interactive: bool = True,
) -> Optional[Path]:
    """
    åœ¨ config.lrc_dir ä¸‹é€’å½’å¯»æ‰¾å’ŒæŸé¦–æ­Œæ›²åŒ¹é…çš„ LRC æ–‡ä»¶
    """
    meta_title_norm = normalize_name(meta.track)
    meta_artists = split_artists(meta.artist)

    candidates: List[Path] = []

    for p in config.lrc_dir.rglob("*.lrc"):
        lrc_artists, lrc_title_norm = parse_lrc_filename(p)
        if not lrc_title_norm:
            continue

        if lrc_title_norm != meta_title_norm:
            continue

        if match_artists(meta_artists, lrc_artists):
            candidates.append(p)

    if not candidates:
        return None

    if len(candidates) == 1 or not interactive:
        return candidates[0]

    # å¤šä¸ªå€™é€‰ â†’ äº¤äº’é€‰æ‹©
    print("\n" + _("åŒ¹é…åˆ°å¤šä¸ªæ­Œè¯æ–‡ä»¶ï¼Œè¯·é€‰æ‹©ï¼š"))
    for idx, c in enumerate(candidates, 1):
        print(f"{idx}) {c}")

    while True:
        choice = input(_("è¯·è¾“å…¥ 1-{max}: ").format(max=len(candidates))).strip()
        if choice.isdigit():
            i = int(choice)
            if 1 <= i <= len(candidates):
                return candidates[i - 1]
        print(_("è¾“å…¥æ— æ•ˆï¼Œè¯·é‡æ–°è¾“å…¥ã€‚"))
./lrc/__init__.py


===== FILE: ./lrc/__init__.py =====

# ===== lrc/__init__.py =====

"""
LRC æ¨¡å—ï¼šè§£æå’ŒåŒ¹é…æ­Œè¯æ–‡ä»¶
"""

from .parser import parse_lrc_file, write_lrc_file, cleanse_lrc_file, ParsedLRC, normalize_name
from .matcher import find_lrc_for_track, split_artists, match_artists

__all__ = [
    "parse_lrc_file",
    "write_lrc_file",
    "cleanse_lrc_file",
    "ParsedLRC",
    "normalize_name",
    "find_lrc_for_track",
    "split_artists",
    "match_artists",
]
./lrc/parser.py


===== FILE: ./lrc/parser.py =====

# ===== lrc/parser.pyï¼ˆå®Œæ•´ i18n ç‰ˆæœ¬ï¼‰=====

from __future__ import annotations

import re
import unicodedata
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional

from ..logging_utils import log_warn, log_error
from ..i18n import get_text as _


# -------------------- æ–‡æœ¬è§„èŒƒåŒ– --------------------


def normalize_name(s: str) -> str:
    """
    å¢å¼ºç‰ˆè§„èŒƒåŒ–ï¼šæ”¯æŒå¤šè¯­è¨€
    """
    s = s.strip().lower()
    
    # Unicode è§„èŒƒåŒ–
    s = unicodedata.normalize('NFKC', s)
    
    # è¥¿é‡Œå°”å­—æ¯æ˜ å°„
    cyrillic_map = {
        'Ñ‘': 'Ğµ',
        'Ñ–': 'Ğ¸',
        'Ñ—': 'Ğ¸',
        'Ñ”': 'Ğµ',
        'Ò‘': 'Ğ³',
    }
    for old, new in cyrillic_map.items():
        s = s.replace(old, new)
    
    # å…¨è§’æ ‡ç‚¹æ›¿æ¢
    replacements = {
        "ï¼ˆ": "(",
        "ï¼‰": ")",
        "ã€": "[",
        "ã€‘": "]",
        "ï¼š": ":",
        "ã€‚": ".",
        "ï¼Œ": ",",
        "ï¼": "!",
        "ï¼Ÿ": "?",
        "ï¼†": "&",
        "ï¼": "/",
        "ï¼›": ";",
    }
    for k, v in replacements.items():
        s = s.replace(k, v)
    
    # ç§»é™¤é›¶å®½å­—ç¬¦å’Œæ§åˆ¶å­—ç¬¦ï¼ˆä¿ç•™ç©ºæ ¼ï¼‰
    s = ''.join(ch for ch in s if unicodedata.category(ch)[0] not in ('C', 'Z') or ch == ' ')
    
    # åˆå¹¶å¤šä½™ç©ºæ ¼
    s = re.sub(r"\s+", " ", s)
    return s.strip()


# -------------------- LRC å†…å®¹è§£æ --------------------

# æ ‡å‡†æ—¶é—´æ ‡ç­¾
TIMESTAMP_RE = re.compile(r"\[\d{2}:\d{2}\.\d{2,3}\]")

# æ‰©å±•æ—¶é—´æ ‡ç­¾
EXTENDED_TIMESTAMP_RE = re.compile(r"\[\d{2}:\d{2}(?:\.\d{1,3}(?:-\d{1,3})?)?\]")

# LRC å¤´éƒ¨æ ‡ç­¾
HEADER_TAG_RE = re.compile(r"^\[[a-zA-Z]{2,3}:.+\]$")

# NCM å¸¸è§ credit å…³é”®å­—
CREDIT_KEYWORDS = (
    "ä½œè¯", "ä½œæ›²", "ç¼–æ›²", "æ··éŸ³", "ç¼©æ··", "å½•éŸ³", "æ¯å¸¦", "åˆ¶ä½œ", "ç›‘åˆ¶", "å’Œå£°", 
    "é…å”±", "åˆ¶ä½œäºº", "æ¼”å”±", "ä¼´å¥", "ç¼–é…", "å‰ä»–", "è´æ–¯", "é¼“", "é”®ç›˜", "å¼¦ä¹", 
    "åˆ¶ä½œå›¢é˜Ÿ", "æ‰“å‡»ä¹", "é‡‡æ ·", "éŸ³æ•ˆ", "äººå£°", "åˆæˆå™¨", "å½•éŸ³å¸ˆ", "æ··éŸ³å¸ˆ", "ç¼–æ›²å¸ˆ",
    "å‡ºå“", "å‘è¡Œ", "ä¼åˆ’", "ç»Ÿç­¹", "åæœŸ", "éŸ³ä¹æ€»ç›‘"
)

CREDIT_RE = re.compile(
    rf"^({'|'.join(re.escape(k) for k in CREDIT_KEYWORDS)})\s*[:ï¼š]\s*.+$"
)

# "çº¯éŸ³ä¹ï¼Œè¯·æ¬£èµ"ç±»æç¤ºå…³é”®å­—
PURE_MUSIC_PHRASES = (
    "çº¯éŸ³ä¹ï¼Œè¯·æ¬£èµ",
    "çº¯éŸ³ä¹, è¯·æ¬£èµ",
    "çº¯éŸ³ä¹ è¯·æ¬£èµ",
    "æ­¤æ­Œæ›²ä¸ºæ²¡æœ‰å¡«è¯çš„çº¯éŸ³ä¹",
    "instrumental",
)


@dataclass
class ParsedLRC:
    """
    LRC è§£æç»“æœï¼š
      - synced: å¸¦æ—¶é—´æˆ³çš„ LRC å†…å®¹ï¼ˆå·²æ ‡å‡†åŒ–ï¼‰
      - plain: çº¯æ–‡æœ¬æ­Œè¯ï¼ˆä¸åŒ…å«æ—¶é—´æ ‡ç­¾ï¼‰
      - is_instrumental: æ˜¯å¦æ£€æµ‹åˆ°"çº¯éŸ³ä¹"æ€§è´¨
    """
    synced: str
    plain: str
    is_instrumental: bool


def read_text_any(path: Path) -> str:
    """
    å°è¯•å¤šç§ç¼–ç è¯»å–æ–‡æœ¬æ–‡ä»¶
    """
    for enc in ("utf-8-sig", "utf-8", "gb18030"):
        try:
            return path.read_text(encoding=enc)
        except UnicodeDecodeError:
            continue
    return path.read_text(encoding="utf-8", errors="ignore")


def _contains_cjk(text: str) -> bool:
    """ç²—ç•¥åˆ¤æ–­æ–‡æœ¬æ˜¯å¦åŒ…å«ä¸­æ—¥éŸ©æ–‡å­—"""
    return bool(re.search(r'[\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF]', text))


def parse_lrc_file(path: Path, *, remove_translations: bool = True) -> ParsedLRC:
    """
    å¢å¼ºç‰ˆ LRC è§£æï¼ˆå¸¦å®¹é”™å¤„ç†ï¼‰
    
    Args:
        path: LRC æ–‡ä»¶è·¯å¾„
        remove_translations: æ˜¯å¦åˆ é™¤é‡å¤æ—¶é—´æˆ³çš„ç¿»è¯‘è¡Œï¼ˆé»˜è®¤ Trueï¼‰
    
    Returns:
        ParsedLRC(synced, plain, is_instrumental)
    """
    # å®¹é”™ï¼šè¯»å–æ–‡ä»¶å¤±è´¥
    try:
        raw = read_text_any(path)
    except Exception as e:
        log_error(_("è¯»å– LRC æ–‡ä»¶å¤±è´¥ {path}: {error}").format(path=path, error=str(e)))
        return ParsedLRC(synced="", plain="", is_instrumental=False)
    
    # å®¹é”™ï¼šæ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆæ—¶é—´æˆ³
    if not TIMESTAMP_RE.search(raw):
        log_warn(_("LRC æ–‡ä»¶æ— æœ‰æ•ˆæ—¶é—´æˆ³: {path}").format(path=path))
        return ParsedLRC(synced="", plain="", is_instrumental=False)
    
    raw = raw.replace("\r\n", "\n").replace("\r", "\n")
    
    synced_lines: List[str] = []
    plain_lines: List[str] = []
    is_instrumental = False
    
    started = False
    prev_timestamp: Optional[str] = None
    
    for line in raw.splitlines():
        s = line.strip()
        
        # é˜¶æ®µ 1: åˆ é™¤æ­Œè¯å¤´
        if not started:
            if TIMESTAMP_RE.match(s):
                started = True
            else:
                continue
        
        # é˜¶æ®µ 2: å¤„ç†å·²å¼€å§‹çš„æ­Œè¯å†…å®¹
        
        # ç©ºè¡Œ
        if not s:
            synced_lines.append("")
            plain_lines.append("")
            prev_timestamp = None
            continue
        
        # LRC å¤´éƒ¨æ ‡ç­¾
        if HEADER_TAG_RE.match(s):
            synced_lines.append(line)
            prev_timestamp = None
            continue
        
        # æå–æ—¶é—´æˆ³å’Œæ­Œè¯æ–‡æœ¬
        timestamp_match = EXTENDED_TIMESTAMP_RE.match(s)
        
        if timestamp_match:
            current_timestamp = timestamp_match.group(0)
            text_no_tag = s[len(current_timestamp):].strip()
            
            # æ£€æµ‹"çº¯éŸ³ä¹ï¼Œè¯·æ¬£èµ"
            if text_no_tag and any(p in text_no_tag for p in PURE_MUSIC_PHRASES):
                is_instrumental = True
                prev_timestamp = None
                continue
            
            # æ£€æµ‹ credit ä¿¡æ¯
            if text_no_tag and CREDIT_RE.match(text_no_tag):
                prev_timestamp = None
                continue
            
            # æ£€æµ‹ä¸­æ–‡ç¿»è¯‘è¡Œ
            if remove_translations and prev_timestamp == current_timestamp:
                if _contains_cjk(text_no_tag):
                    continue
            
            # æ­£å¸¸æ­Œè¯è¡Œ
            synced_lines.append(line)
            plain_lines.append(text_no_tag)
            prev_timestamp = current_timestamp
        
        else:
            synced_lines.append(line)
            if s:
                plain_lines.append(s)
            prev_timestamp = None
    
    # æ¸…ç† plain é¡¶éƒ¨/å°¾éƒ¨çš„ç©ºè¡Œ
    while plain_lines and not plain_lines[0]:
        plain_lines.pop(0)
    while plain_lines and not plain_lines[-1]:
        plain_lines.pop()
    
    synced = "\n".join(synced_lines)
    plain = "\n".join(plain_lines)
    
    return ParsedLRC(
        synced=synced,
        plain=plain,
        is_instrumental=is_instrumental,
    )


def write_lrc_file(path: Path, content: str) -> bool:
    """
    å°†æ ‡å‡†åŒ–åçš„ LRC å†…å®¹å†™å›æ–‡ä»¶ï¼ˆä½¿ç”¨ UTF-8 ç¼–ç ï¼‰
    """
    try:
        path.write_text(content, encoding='utf-8')
        return True
    except Exception as e:
        log_error(_("å†™å…¥ LRC æ–‡ä»¶å¤±è´¥ {path}: {error}").format(path=path, error=str(e)))
        return False


def cleanse_lrc_file(path: Path) -> bool:
    """
    æ ‡å‡†åŒ– LRC æ–‡ä»¶ï¼ˆin-placeï¼‰
    
    ç­‰ä»·äºï¼š
        parsed = parse_lrc_file(path)
        write_lrc_file(path, parsed.synced)
    
    Args:
        path: LRC æ–‡ä»¶è·¯å¾„
    
    Returns:
        æ˜¯å¦æˆåŠŸæ ‡å‡†åŒ–
    """
    try:
        parsed = parse_lrc_file(path)
        return write_lrc_file(path, parsed.synced)
    except Exception as e:
        log_error(_("æ ‡å‡†åŒ– LRC æ–‡ä»¶å¤±è´¥ {path}: {error}").format(path=path, error=str(e)))
        return False
./model/track.py


===== FILE: ./model/track.py =====

# ===== model/track.pyï¼ˆå®Œæ•´ i18n ç‰ˆæœ¬ï¼‰=====

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Optional, Dict, Any

from mutagen import File as MutaFile
from mutagen.id3 import ID3NoHeaderError

from ..logging_utils import log_warn, log_error, log_debug
from ..i18n import get_text as _


# å„æ ¼å¼æ ‡ç­¾é”®æ˜ å°„ï¼ˆç»Ÿä¸€åˆ° title, artist, albumï¼‰
TAG_MAPPINGS: Dict[str, Dict[str, list[str]]] = {
    # MP3 (ID3v2)
    "mp3": {
        "title": ["TIT2"],
        "artist": ["TPE1"],
        "album": ["TALB"],
    },
    # M4A/AAC (iTunes MP4)
    "m4a": {
        "title": ["Â©nam", "\xa9nam"],
        "artist": ["Â©ART", "\xa9ART"],
        "album": ["Â©alb", "\xa9alb"],
    },
    "aac": {  # åŒ m4a
        "title": ["Â©nam", "\xa9nam"],
        "artist": ["Â©ART", "\xa9ART"],
        "album": ["Â©alb", "\xa9alb"],
    },
    # FLAC (Vorbis Comments)
    "flac": {
        "title": ["TITLE", "title"],
        "artist": ["ARTIST", "artist"],
        "album": ["ALBUM", "album"],
    },
    # WAV (é€šå¸¸ä½¿ç”¨ ID3 æˆ–æ— æ ‡ç­¾)
    "wav": {
        "title": ["TIT2", "TITLE", "title"],
        "artist": ["TPE1", "ARTIST", "artist"],
        "album": ["TALB", "ALBUM", "album"],
    },
}


@dataclass
class TrackMeta:
    """
    è¡¨ç¤ºä¸€é¦–æ­Œæ›²çš„å…ƒæ•°æ®ï¼ˆä»éŸ³é¢‘æ–‡ä»¶è¯»å–ï¼‰
    """

    path: Path
    track: str
    artist: str
    album: str
    duration: int  # ç§’

    def __str__(self) -> str:
        return f"{self.artist} - {self.track} ({self.album}, {self.duration}s)"

    @staticmethod
    def _get_universal_tag(audio: Any, field: str, ext: str) -> Optional[str]:
        """
        ç»Ÿä¸€çš„æ ‡ç­¾è¯»å–æ¥å£ï¼ˆæ”¯æŒå¤šç§éŸ³é¢‘æ ¼å¼ï¼‰
        
        Args:
            audio: Mutagen éŸ³é¢‘å¯¹è±¡
            field: å­—æ®µåï¼ˆtitle/artist/albumï¼‰
            ext: æ–‡ä»¶æ‰©å±•åï¼ˆä¸å«ç‚¹ï¼Œå¦‚ "mp3"ï¼‰
        
        Returns:
            æ ‡ç­¾å€¼å­—ç¬¦ä¸²ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å› None
        """
        if not audio or not audio.tags:
            return None
        
        # è·å–è¯¥æ ¼å¼å¯¹åº”çš„æ ‡ç­¾é”®åˆ—è¡¨
        mapping = TAG_MAPPINGS.get(ext, {})
        possible_keys = mapping.get(field, [])
        
        # å°è¯•æ‰€æœ‰å¯èƒ½çš„é”®
        for key in possible_keys:
            try:
                value = audio.tags.get(key)
                if value is None:
                    continue
                
                # å¤„ç†ä¸åŒæ ¼å¼çš„è¿”å›å€¼
                if isinstance(value, list) and value:
                    return str(value[0])
                elif hasattr(value, "text") and value.text:
                    return str(value.text[0])
                elif isinstance(value, str):
                    return value
                else:
                    # å°è¯•ç›´æ¥è½¬å­—ç¬¦ä¸²
                    result = str(value)
                    if result:
                        return result
            except Exception as e:
                log_debug(_("è¯»å–æ ‡ç­¾ {key} å¤±è´¥: {error}").format(key=key, error=str(e)))
                continue
        
        return None

    @classmethod
    def from_audio_file(cls, audio_path: Path) -> Optional["TrackMeta"]:
        """
        ä»éŸ³é¢‘æ–‡ä»¶è¯»å–å…ƒæ•°æ®ï¼ˆæ”¯æŒ MP3, M4A, AAC, FLAC, WAVï¼‰
        
        å‡ºç°å¼‚å¸¸/æ ‡ç­¾ä¸å®Œæ•´æ—¶è¿”å› Noneã€‚
        """
        ext = audio_path.suffix.lower().strip(".")
        
        try:
            audio = MutaFile(audio_path)
            if audio is None:
                log_warn(_("æ— æ³•è¯»å–éŸ³é¢‘æ–‡ä»¶ï¼š{filename}").format(filename=audio_path.name))
                return None
        except ID3NoHeaderError:
            log_warn(_("éŸ³é¢‘æ–‡ä»¶æ— æ ‡ç­¾ï¼š{filename}").format(filename=audio_path.name))
            return None
        except Exception as e:
            log_error(_("è¯»å–éŸ³é¢‘æ–‡ä»¶å¼‚å¸¸ {filename}: {error}").format(filename=audio_path.name, error=str(e)))
            return None

        # ä½¿ç”¨ç»Ÿä¸€æ¥å£è¯»å–æ ‡ç­¾
        track = cls._get_universal_tag(audio, "title", ext)
        artist = cls._get_universal_tag(audio, "artist", ext)
        album = cls._get_universal_tag(audio, "album", ext)

        if not track or not artist or not album:
            log_warn(_("éŸ³é¢‘æ–‡ä»¶æ ‡ç­¾ä¸å®Œæ•´ï¼š{filename}").format(filename=audio_path.name))
            return None

        # è¯»å–æ—¶é•¿
        duration = 0
        if hasattr(audio, "info") and hasattr(audio.info, "length"):
            duration = int(round(audio.info.length))
        
        if duration <= 0:
            log_warn(_("éŸ³é¢‘æ–‡ä»¶æ—¶é•¿æ— æ•ˆï¼š{filename}").format(filename=audio_path.name))
            return None

        return cls(
            path=audio_path,
            track=track,
            artist=artist,
            album=album,
            duration=duration,
        )

    @classmethod
    def from_mp3(cls, mp3_path: Path) -> Optional["TrackMeta"]:
        """
        å‘åå…¼å®¹çš„æ–¹æ³•ï¼ˆè°ƒç”¨ from_audio_fileï¼‰
        
        âš ï¸ å·²å¼ƒç”¨ï¼Œè¯·ä½¿ç”¨ from_audio_file()
        """
        return cls.from_audio_file(mp3_path)
./model/lyrics.py


===== FILE: ./model/lyrics.py =====

from __future__ import annotations

from dataclasses import dataclass
from typing import Optional, Dict, Any


@dataclass
class LyricsRecord:
    """
    è¡¨ç¤ºä» LRCLIB API è¿”å›çš„æ­Œè¯è®°å½•
    """

    plain: str
    synced: str
    instrumental: bool

    @classmethod
    def from_api(cls, data: Dict[str, Any]) -> "LyricsRecord":
        """
        ä» API è¿”å›çš„ JSON æ„é€  LyricsRecord
        
        API è¿”å›æ ¼å¼ï¼š
        {
            "plainLyrics": "...",
            "syncedLyrics": "...",
            "instrumental": false,
            ...
        }
        """
        plain = data.get("plainLyrics") or ""
        synced = data.get("syncedLyrics") or ""
        instrumental = bool(data.get("instrumental", False))
        
        # å¦‚æœä¸¤ä¸ªæ­Œè¯å­—æ®µéƒ½ä¸ºç©ºä¸”æ²¡æœ‰æ˜ç¡®æ ‡è®° instrumentalï¼Œ
        # ä¹Ÿè§†ä¸ºçº¯éŸ³ä¹
        if not plain.strip() and not synced.strip() and not instrumental:
            instrumental = True
        
        return cls(
            plain=plain,
            synced=synced,
            instrumental=instrumental,
        )

    def is_empty(self) -> bool:
        """åˆ¤æ–­æ­Œè¯æ˜¯å¦ä¸ºç©º"""
        return not self.plain.strip() and not self.synced.strip()
./model/__init__.py


===== FILE: ./model/__init__.py =====

"""
æ•°æ®æ¨¡å‹æ¨¡å—
"""

from .track import TrackMeta
from .lyrics import LyricsRecord

__all__ = [
    "TrackMeta",
    "LyricsRecord",
]
./api/pow.py


===== FILE: ./api/pow.py =====

# ===== api/pow.pyï¼ˆå®Œæ•´ i18n ç‰ˆæœ¬ï¼‰=====

from __future__ import annotations

import hashlib

from ..exceptions import PoWError
from ..logging_utils import log_info
from ..i18n import get_text as _


def solve_pow(prefix: str, target_hex: str) -> str:
    """
    æŒ‰å®˜æ–¹è¯´æ˜ + LRCGET çš„å®ç°ä¹ æƒ¯ï¼š

    - target æ˜¯ 16 è¿›åˆ¶å­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸€ä¸ª 256 ä½æ•´æ•°é˜ˆå€¼
    - åœ¨ nonce ä¸º 0,1,2,... ä¸­å¯»æ‰¾ç¬¬ä¸€ä¸ªæ»¡è¶³ï¼š
        sha256(prefix + str(nonce)) <= target
    - è¿”å› nonce çš„åè¿›åˆ¶å­—ç¬¦ä¸²
    """
    if not prefix or not target_hex:
        raise PoWError(_("æ— æ•ˆ PoW å‚æ•°ï¼šprefix={prefix}, target={target}").format(
            prefix=repr(prefix),
            target=repr(target_hex)
        ))

    target = int(target_hex, 16)

    nonce = 0
    while True:
        token_bytes = (prefix + str(nonce)).encode("utf-8")
        digest = hashlib.sha256(token_bytes).hexdigest()
        if int(digest, 16) <= target:
            log_info(_("æ‰¾åˆ°æœ‰æ•ˆ nonce: {nonce}").format(nonce=nonce))
            return str(nonce)
        nonce += 1
./api/client.py


===== FILE: ./api/client.py =====

# ===== api/client.pyï¼ˆå®Œæ•´ i18n ç‰ˆæœ¬ï¼‰=====

from __future__ import annotations

from typing import Optional

from ..config import AppConfig
from ..model import TrackMeta, LyricsRecord
from ..logging_utils import log_info, log_warn
from ..i18n import get_text as _
from .http import http_request_json
from .publish import (
    upload_lyrics as _upload_lyrics_impl,
    upload_instrumental as _upload_instrumental_impl,
)


def _check_duration(meta: TrackMeta, record: dict, label: str) -> None:
    """
    æ‰“å° LRCLIB è¿”å›çš„ duration ä¸æœ¬åœ° duration çš„å·®å€¼æç¤ºã€‚
    """
    rec_dur = record.get("duration")
    if rec_dur is None:
        return

    try:
        rec_dur_int = int(round(float(rec_dur)))
    except Exception:
        return

    diff = abs(rec_dur_int - meta.duration)
    if diff <= 2:
        log_info(
            _("{label} æ—¶é•¿æ£€æŸ¥ï¼šLRCLIB={rec_dur}s, æœ¬åœ°={local_dur}s, å·®å€¼={diff}sï¼ˆ<=2sï¼Œç¬¦åˆåŒ¹é…æ¡ä»¶ï¼‰").format(
                label=label,
                rec_dur=rec_dur_int,
                local_dur=meta.duration,
                diff=diff
            )
        )
    else:
        log_warn(
            _("{label} æ—¶é•¿æ£€æŸ¥ï¼šLRCLIB={rec_dur}s, æœ¬åœ°={local_dur}s, å·®å€¼={diff}sï¼ˆ>2sï¼Œå¯èƒ½ä¸æ˜¯åŒä¸€é¦–ï¼‰").format(
                label=label,
                rec_dur=rec_dur_int,
                local_dur=meta.duration,
                diff=diff
            )
        )


class ApiClient:
    """
    é«˜å±‚ API å°è£…ï¼š

    - get_cached()  : è°ƒç”¨ /api/get-cachedï¼ŒåªæŸ¥å†…éƒ¨æ•°æ®åº“
    - get_external(): è°ƒç”¨ /api/getï¼Œä¼šè§¦å‘ LRCLIB å¤–éƒ¨æŠ“å–
    - upload_lyrics(): è¯­ä¹‰åŒ–åŒ…è£… /api/publishï¼ˆå¸¦æ­Œè¯ï¼‰
    - upload_instrumental(): è¯­ä¹‰åŒ–åŒ…è£… /api/publishï¼ˆçº¯éŸ³ä¹ï¼‰
    """

    def __init__(self, config: AppConfig) -> None:
        self.config = config

    def _api_get_common(
        self,
        meta: TrackMeta,
        endpoint: str,
        label: str,
    ) -> Optional[LyricsRecord]:
        """
        é€šç”¨çš„ /api/get* è°ƒç”¨é€»è¾‘
        """
        params = {
            "track_name": meta.track,
            "artist_name": meta.artist,
            "album_name": meta.album,
            "duration": meta.duration,
        }

        url = f"{self.config.lrclib_base}/{endpoint}"

        data = http_request_json(
            self.config,
            method="GET",
            url=url,
            label=label,
            params=params,
        )
        if not data:
            return None

        _check_duration(meta, data, label)
        return LyricsRecord.from_api(data)

    def get_cached(self, meta: TrackMeta) -> Optional[LyricsRecord]:
        """
        è°ƒç”¨ /api/get-cachedï¼šåªæŸ¥ LRCLIB å†…éƒ¨æ•°æ®åº“
        """
        return self._api_get_common(meta, "get-cached", _("å†…éƒ¨æ•°æ®åº“ (/api/get-cached)"))

    def get_external(self, meta: TrackMeta) -> Optional[LyricsRecord]:
        """
        è°ƒç”¨ /api/getï¼šä¼šè§¦å‘ LRCLIB å¯¹å¤–éƒ¨æ¥æºçš„æŠ“å–
        """
        return self._api_get_common(meta, "get", _("å¤–éƒ¨æŠ“å– (/api/get)"))

    def upload_lyrics(self, meta: TrackMeta, plain: str, synced: str) -> bool:
        """é«˜å±‚åŒ…è£…ï¼šä¸Šä¼ å¸¦ plain+synced çš„æ­Œè¯"""
        return _upload_lyrics_impl(self.config, meta, plain, synced)

    def upload_instrumental(self, meta: TrackMeta) -> bool:
        """é«˜å±‚åŒ…è£…ï¼šä»¥"çº¯éŸ³ä¹"æ–¹å¼ä¸Šä¼ """
        return _upload_instrumental_impl(self.config, meta)
./api/__init__.py


===== FILE: ./api/__init__.py =====

"""
API æ¨¡å—ï¼šä¸ LRCLIB äº¤äº’
"""

from .client import ApiClient
from .publish import upload_lyrics, upload_instrumental

__all__ = [
    "ApiClient",
    "upload_lyrics",
    "upload_instrumental",
]
./api/http.py


===== FILE: ./api/http.py =====

# ===== api/http.pyï¼ˆå®Œæ•´ i18n ç‰ˆæœ¬ï¼‰=====

from __future__ import annotations

import random
import time
from typing import Optional, Dict, Any

import requests
from requests import RequestException

from ..config import AppConfig
from ..logging_utils import log_info, log_warn, log_error
from ..i18n import get_text as _


def _calculate_backoff(attempt: int, base: float = 1.0, max_delay: float = 30.0) -> float:
    """
    è®¡ç®—æŒ‡æ•°é€€é¿å»¶è¿Ÿæ—¶é—´ï¼ˆå¸¦æŠ–åŠ¨ï¼‰
    
    Args:
        attempt: å½“å‰é‡è¯•æ¬¡æ•°ï¼ˆä» 1 å¼€å§‹ï¼‰
        base: åŸºç¡€å»¶è¿Ÿæ—¶é—´
        max_delay: æœ€å¤§å»¶è¿Ÿæ—¶é—´
    
    Returns:
        å»¶è¿Ÿç§’æ•°
    """
    delay = min(base * (2 ** (attempt - 1)) + random.uniform(0, 1), max_delay)
    return delay


def http_request_json(
    config: AppConfig,
    method: str,
    url: str,
    label: str,
    *,
    params: Optional[Dict[str, Any]] = None,
    json_data: Optional[Dict[str, Any]] = None,
    timeout: int = 20,
    max_retries: Optional[int] = None,
    treat_404_as_none: bool = True,
) -> Optional[Dict[str, Any]]:
    """
    å°è£… GET / POST JSON è¯·æ±‚çš„é€šç”¨å‡½æ•°ï¼š

    - éµå¾ª config.max_http_retries è¿›è¡Œé‡è¯•
    - å¯¹ç½‘ç»œå¼‚å¸¸ / 5xx åšè‡ªåŠ¨é‡è¯•ï¼ˆä½¿ç”¨æŒ‡æ•°é€€é¿ï¼‰
    - 404 å¯é€‰è§†ä¸º None
    - å…¶ä½™ 4xx æŠ¥é”™åä¸é‡è¯•
    """
    retries = max_retries if max_retries is not None else config.max_http_retries

    for attempt in range(1, retries + 1):
        try:
            resp = requests.request(
                method=method,
                url=url,
                params=params,
                json=json_data,
                timeout=timeout,
                headers={"User-Agent": config.user_agent},
            )
        except RequestException as e:
            backoff = _calculate_backoff(attempt)
            log_warn(
                _("{label} è°ƒç”¨å¤±è´¥ï¼ˆç¬¬ {attempt}/{retries} æ¬¡ï¼‰ï¼Œç­‰å¾… {backoff:.1f}s åé‡è¯•: {error}").format(
                    label=label,
                    attempt=attempt,
                    retries=retries,
                    backoff=backoff,
                    error=str(e)
                )
            )
            if attempt == retries:
                return None
            time.sleep(backoff)
            continue

        # ç‰¹æ®Šå¤„ç† 404
        if resp.status_code == 404 and treat_404_as_none:
            return None

        if 200 <= resp.status_code < 300:
            try:
                return resp.json()
            except ValueError as e:
                log_warn(
                    _("{label} è§£æ JSON å¤±è´¥: {error} (status={status}, body={body})").format(
                        label=label,
                        error=str(e),
                        status=resp.status_code,
                        body=resp.text[:200]
                    )
                )
                return None

        # 4xx é»˜è®¤è®¤ä¸ºæ˜¯å‚æ•°/è®¤è¯é—®é¢˜ï¼Œä¸é‡è¯•
        if 400 <= resp.status_code < 500:
            log_warn(
                _("{label} è¯·æ±‚å¤±è´¥ï¼šHTTP {status}, body={body}").format(
                    label=label,
                    status=resp.status_code,
                    body=resp.text[:200]
                )
            )
            return None

        # 5xx â†’ é‡è¯•
        backoff = _calculate_backoff(attempt)
        log_warn(
            _("{label} è¯·æ±‚å¤±è´¥ï¼šHTTP {status}, body={body}ï¼ˆç¬¬ {attempt}/{retries} æ¬¡ï¼‰ï¼Œç­‰å¾… {backoff:.1f}s åé‡è¯•").format(
                label=label,
                status=resp.status_code,
                body=resp.text[:200],
                attempt=attempt,
                retries=retries,
                backoff=backoff
            )
        )
        if attempt == retries:
            return None
        time.sleep(backoff)

    return None
./api/publish.py


===== FILE: ./api/publish.py =====

# ===== api/publish.pyï¼ˆå®Œæ•´ i18n ç‰ˆæœ¬ï¼‰=====

from __future__ import annotations

import random
import time
from typing import Optional, Dict, Any

import requests
from requests import RequestException

from ..config import AppConfig
from ..model import TrackMeta
from ..logging_utils import log_info, log_warn, log_error
from ..i18n import get_text as _
from .http import http_request_json
from .pow import solve_pow


# -------------------- Publish Token / PoW --------------------


def request_publish_token(config: AppConfig) -> Optional[str]:
    """
    è°ƒç”¨ /api/request-challengeï¼Œæ‰§è¡Œ PoWï¼Œè¿”å›å®Œæ•´çš„
      X-Publish-Token = "{prefix}:{nonce}"
    """
    url = f"{config.lrclib_base}/request-challenge"
    data = http_request_json(
        config,
        "POST",
        url,
        _("è¯·æ±‚å‘å¸ƒä»¤ç‰Œ (/api/request-challenge)"),
        treat_404_as_none=False,
    )
    if not data:
        return None

    prefix = data.get("prefix")
    target = data.get("target")
    if not prefix or not target:
        log_error(_("è¯·æ±‚å‘å¸ƒä»¤ç‰Œè¿”å›å¼‚å¸¸æ•°æ®ï¼š{data}").format(data=data))
        return None

    try:
        nonce = solve_pow(prefix, target)
    except Exception as e:
        log_error(_("PoW æ±‚è§£å¤±è´¥ï¼š{error}").format(error=str(e)))
        return None

    return f"{prefix}:{nonce}"


# -------------------- Publish with retry --------------------


def _calculate_backoff(attempt: int, base: float = 1.0, max_delay: float = 30.0) -> float:
    """è®¡ç®—æŒ‡æ•°é€€é¿å»¶è¿Ÿæ—¶é—´ï¼ˆå¸¦æŠ–åŠ¨ï¼‰"""
    return min(base * (2 ** (attempt - 1)) + random.uniform(0, 1), max_delay)


def publish_with_retry(
    config: AppConfig,
    meta: TrackMeta,
    payload: Dict[str, Any],
    label: str,
) -> bool:
    """
    å¯¹ /api/publish åšä¸€å±‚è‡ªåŠ¨é‡è¯•ï¼š
      - æ¯æ¬¡é‡è¯•éƒ½ä¼šé‡æ–°è¯·æ±‚ challenge + é‡æ–° PoW
      - æˆåŠŸï¼ˆ201ï¼‰å³è¿”å› True
      - 4xx è®¤ä¸ºæ˜¯å‚æ•°æˆ– Token é—®é¢˜ï¼Œä¸é‡è¯•
    """
    url = f"{config.lrclib_base}/publish"
    retries = config.max_http_retries

    for attempt in range(1, retries + 1):
        token = request_publish_token(config)
        if not token:
            backoff = _calculate_backoff(attempt)
            log_warn(
                _("{label}ï¼šè·å–å‘å¸ƒä»¤ç‰Œå¤±è´¥ï¼ˆç¬¬ {attempt}/{retries} æ¬¡ï¼‰ï¼Œç­‰å¾… {backoff:.1f}s åé‡è¯•").format(
                    label=label,
                    attempt=attempt,
                    retries=retries,
                    backoff=backoff
                )
            )
            if attempt == retries:
                return False
            time.sleep(backoff)
            continue

        headers = {
            "X-Publish-Token": token,
            "Content-Type": "application/json",
            "User-Agent": config.user_agent,
        }

        try:
            resp = requests.post(url, json=payload, headers=headers, timeout=30)
        except RequestException as e:
            backoff = _calculate_backoff(attempt)
            log_warn(
                _("{label} (/api/publish) è°ƒç”¨å¤±è´¥ï¼ˆç¬¬ {attempt}/{retries} æ¬¡ï¼‰ï¼Œç­‰å¾… {backoff:.1f}s åé‡è¯•: {error}").format(
                    label=label,
                    attempt=attempt,
                    retries=retries,
                    backoff=backoff,
                    error=str(e)
                )
            )
            if attempt == retries:
                return False
            time.sleep(backoff)
            continue

        if resp.status_code == 201:
            return True

        # 4xx: å‚æ•°/Token é”™è¯¯ï¼Œä¸å†é‡è¯•
        if 400 <= resp.status_code < 500:
            log_error(
                _("{label} å¤±è´¥ï¼šHTTP {status}, body={body}ï¼ˆ4xx é”™è¯¯ï¼Œä¸€èˆ¬æ˜¯å‚æ•°æˆ– Token é—®é¢˜ï¼Œä¸å†é‡è¯•ï¼‰").format(
                    label=label,
                    status=resp.status_code,
                    body=resp.text[:200]
                )
            )
            return False

        # 5xx: é‡è¯•
        backoff = _calculate_backoff(attempt)
        log_warn(
            _("{label} å¤±è´¥ï¼šHTTP {status}, body={body}ï¼ˆç¬¬ {attempt}/{retries} æ¬¡ï¼‰ï¼Œç­‰å¾… {backoff:.1f}s åé‡è¯•").format(
                label=label,
                status=resp.status_code,
                body=resp.text[:200],
                attempt=attempt,
                retries=retries,
                backoff=backoff
            )
        )
        if attempt == retries:
            return False
        time.sleep(backoff)

    return False


# -------------------- Payload æ„é€  --------------------


def build_payload_for_publish(
    meta: TrackMeta,
    plain: Optional[str],
    synced: Optional[str],
    *,
    force_instrumental: bool = False,
) -> Dict[str, Any]:
    """
    æ„é€  /api/publish çš„ JSON
    """
    base: Dict[str, Any] = {
        "trackName": meta.track,
        "artistName": meta.artist,
        "albumName": meta.album,
        "duration": meta.duration,
    }

    if force_instrumental:
        return base

    p = (plain or "").strip()
    s = (synced or "").strip()

    if not p and not s:
        return base

    base["plainLyrics"] = p
    base["syncedLyrics"] = s
    return base


# -------------------- é«˜é˜¶ä¸Šä¼ å‡½æ•° --------------------


def upload_lyrics(
    config: AppConfig,
    meta: TrackMeta,
    plain: str,
    synced: str,
) -> bool:
    payload = build_payload_for_publish(meta, plain, synced, force_instrumental=False)
    return publish_with_retry(config, meta, payload, _("ä¸Šä¼ æ­Œè¯"))


def upload_instrumental(config: AppConfig, meta: TrackMeta) -> bool:
    """æŒ‰"çº¯éŸ³ä¹æ›²ç›®"ä¸Šä¼ """
    payload = build_payload_for_publish(meta, plain=None, synced=None, force_instrumental=True)
    return publish_with_retry(config, meta, payload, _("ä¸Šä¼ çº¯éŸ³ä¹æ ‡è®°"))
./exceptions.py


===== FILE: ./exceptions.py =====

from __future__ import annotations


class PylrclibupError(Exception):
    """åŒ…å†…è‡ªå®šä¹‰å¼‚å¸¸çš„åŸºç±»ã€‚"""


class NetworkError(PylrclibupError):
    """è¡¨ç¤ºç½‘ç»œç›¸å…³é”™è¯¯ï¼ˆå¦‚å¤šæ¬¡é‡è¯•ä»å¤±è´¥ï¼‰ã€‚"""


class PublishTokenError(PylrclibupError):
    """è·å–æˆ–éªŒè¯å‘å¸ƒ Token å¤±è´¥ã€‚"""


class PoWError(PylrclibupError):
    """PoW æ±‚è§£å¤±è´¥æˆ– challenge æ•°æ®å¼‚å¸¸ã€‚"""


class ApiResponseError(PylrclibupError):
    """LRCLIB API è¿”å›äº†éé¢„æœŸçš„å“åº”ã€‚"""


class LrcNotFoundError(PylrclibupError):
    """ä¸ºæŸé¦–æ­Œæ‰¾ä¸åˆ°å¯¹åº”çš„ LRC æ–‡ä»¶ã€‚"""

class ApiError(PylrclibupError):
    """API è°ƒç”¨ç›¸å…³å¼‚å¸¸"""
    pass

class ConfigError(PylrclibupError):
    """é…ç½®ç›¸å…³å¼‚å¸¸"""
    pass

class LrcParseError(PylrclibupError):
    """LRC è§£æç›¸å…³å¼‚å¸¸"""
    pass

class InstrumentalDetected(PylrclibupError):
    """
    æ ‡è®°è§£æè¿‡ç¨‹ä¸­æ£€æµ‹åˆ°çº¯éŸ³ä¹ã€‚
    åœ¨æŸäº›é«˜çº§ç”¨æ³•ä¸‹ï¼Œå¯èƒ½å¸Œæœ›é€šè¿‡å¼‚å¸¸æ¥ä¸­æ–­æ™®é€šæ­Œè¯æµç¨‹ã€‚
    """
./i18n.py


===== FILE: ./i18n.py =====

# ===== pylrclibup/i18n.pyï¼ˆå®Œæ•´ç‰ˆï¼‰=====

"""
å›½é™…åŒ– (i18n) æ”¯æŒæ¨¡å—
"""

import gettext
import os
from pathlib import Path
from typing import Optional, Callable

# å…¨å±€ç¿»è¯‘å‡½æ•°ï¼ˆç±»å‹æ³¨è§£ï¼‰
_translate: Callable[[str], str] = lambda x: x


def setup_i18n(
    locale: Optional[str] = None,
    localedir: Optional[Path] = None,
) -> None:
    """
    åˆå§‹åŒ–å›½é™…åŒ–æ”¯æŒ
    
    Args:
        locale: è¯­è¨€ä»£ç ï¼ˆå¦‚ 'en_US'ã€'zh_CN'ï¼‰ï¼ŒNone åˆ™è‡ªåŠ¨æ£€æµ‹
        localedir: ç¿»è¯‘æ–‡ä»¶ç›®å½•ï¼ŒNone åˆ™ä½¿ç”¨é»˜è®¤ä½ç½®
    """
    global _translate
    
    # é»˜è®¤ç¿»è¯‘æ–‡ä»¶ä½ç½®
    if localedir is None:
        localedir = Path(__file__).parent / "locales"
    
    # è‡ªåŠ¨æ£€æµ‹è¯­è¨€
    if locale is None:
        locale = _detect_locale()
    
    # å¦‚æœæ˜¯ä¸­æ–‡ï¼ˆæºè¯­è¨€ï¼‰ï¼Œç›´æ¥è¿”å›
    if locale.startswith('zh'):
        _translate = lambda x: x
        return
    
    try:
        # åŠ è½½ç¿»è¯‘
        translation = gettext.translation(
            domain='pylrclibup',
            localedir=str(localedir),
            languages=[locale],
            fallback=False,
        )
        _translate = translation.gettext
    except (FileNotFoundError, OSError):
        # ç¿»è¯‘æ–‡ä»¶ä¸å­˜åœ¨ï¼Œfallback åˆ°ä¸­æ–‡
        _translate = lambda x: x


def _detect_locale() -> str:
    """
    è‡ªåŠ¨æ£€æµ‹ç³»ç»Ÿè¯­è¨€
    
    ä¼˜å…ˆçº§ï¼š
    1. ç¯å¢ƒå˜é‡ PYLRCLIBUP_LANG
    2. ç¯å¢ƒå˜é‡ LANG / LC_ALL
    3. é»˜è®¤ zh_CN
    """
    # 1. ç”¨æˆ·æ˜¾å¼æŒ‡å®š
    if pylrclib_lang := os.getenv('PYLRCLIBUP_LANG'):
        return pylrclib_lang
    
    # 2. ç³»ç»Ÿç¯å¢ƒå˜é‡
    for var in ['LANG', 'LC_ALL', 'LC_MESSAGES']:
        if lang := os.getenv(var):
            return lang.split('.')[0]
    
    # 3. é»˜è®¤ä¸­æ–‡
    return 'zh_CN'


def get_text(message: str) -> str:
    """è·å–ç¿»è¯‘åçš„æ–‡æœ¬"""
    return _translate(message)


# å¯¼å‡ºä¾¿æ·åˆ«å
_ = get_text
./fs/mover.py


===== FILE: ./fs/mover.py =====

# ===== fs/mover.pyï¼ˆå®Œæ•´ i18n ç‰ˆæœ¬ï¼‰=====

from __future__ import annotations

from pathlib import Path
from typing import Optional

from ..logging_utils import log_warn
from ..i18n import get_text as _


def move_with_dedup(
    src: Path,
    dst_dir: Path,
    *,
    new_name: Optional[str] = None
) -> Optional[Path]:
    """
    å°† src ç§»åŠ¨åˆ° dst_dirï¼Œè‹¥åŒåæ–‡ä»¶å·²å­˜åœ¨ï¼Œåˆ™è‡ªåŠ¨æ·»åŠ  _dup åç¼€ã€‚
    
    ç‰¹æ®Šå¤„ç†ï¼š
      - å¦‚æœæºæ–‡ä»¶å·²åœ¨ç›®æ ‡ç›®å½•ä¸”æ— éœ€é‡å‘½å â†’ ç›´æ¥è¿”å›æºè·¯å¾„
      - å¦‚æœç›®æ ‡æ–‡ä»¶å­˜åœ¨ä¸”ä¸æºæ–‡ä»¶ä¸åŒ â†’ æ·»åŠ  _dup åç¼€

    è¿”å›æœ€ç»ˆè·¯å¾„ï¼›è‹¥å¤±è´¥è¿”å› Noneã€‚
    """
    try:
        dst_dir.mkdir(parents=True, exist_ok=True)
        
        # ç¡®å®šç›®æ ‡æ–‡ä»¶å
        if new_name:
            target = dst_dir / f"{new_name}{src.suffix}"
        else:
            target = dst_dir / src.name
        
        # æ£€æŸ¥æ˜¯å¦ä¸ºåŸåœ°ç§»åŠ¨
        src_resolved = src.resolve()
        target_resolved = target.resolve()
        
        if src_resolved == target_resolved:
            return src
        
        # å¤„ç†é‡åæƒ…å†µ
        if target.exists():
            stem = target.stem
            suffix = target.suffix
            dedup = 1
            while True:
                candidate = dst_dir / f"{stem}_dup{dedup}{suffix}"
                if not candidate.exists():
                    target = candidate
                    break
                dedup += 1
        
        # æ‰§è¡Œç§»åŠ¨/é‡å‘½å
        src.rename(target)
        return target

    except Exception as e:
        log_warn(_("ç§»åŠ¨æ–‡ä»¶å¤±è´¥ï¼š{src} â†’ {dst}ï¼š{error}").format(src=src, dst=dst_dir, error=str(e)))
        return None
./fs/__init__.py


===== FILE: ./fs/__init__.py =====

"""
æ–‡ä»¶ç³»ç»Ÿæ“ä½œæ¨¡å—
"""

from .mover import move_with_dedup
from .cleaner import cleanup_empty_dirs

__all__ = [
    "move_with_dedup",
    "cleanup_empty_dirs",
]
./fs/cleaner.py


===== FILE: ./fs/cleaner.py =====

# ===== fs/cleaner.pyï¼ˆå®Œæ•´ i18n ç‰ˆæœ¬ï¼‰=====

from __future__ import annotations

from pathlib import Path

from ..logging_utils import log_info, log_warn
from ..i18n import get_text as _


def cleanup_empty_dirs(root: Path) -> None:
    """
    é€’å½’åˆ é™¤ root ä¸‹çš„ç©ºç›®å½•ï¼ˆä¸åˆ é™¤ root æœ¬èº«ï¼‰
    
    é‡‡ç”¨è‡ªåº•å‘ä¸Šçš„æ–¹å¼ï¼Œç¡®ä¿å­ç›®å½•å…ˆäºçˆ¶ç›®å½•è¢«æ£€æŸ¥
    """
    if not root.exists() or not root.is_dir():
        return
    
    # æ”¶é›†æ‰€æœ‰å­ç›®å½•ï¼ˆè‡ªåº•å‘ä¸Šæ’åºï¼‰
    all_dirs = sorted(root.rglob("*"), key=lambda p: len(p.parts), reverse=True)
    
    for d in all_dirs:
        if not d.is_dir():
            continue
        
        try:
            # æ£€æŸ¥ç›®å½•æ˜¯å¦ä¸ºç©º
            if not any(d.iterdir()):
                d.rmdir()
                log_info(_("å·²åˆ é™¤ç©ºç›®å½•ï¼š{dir}").format(dir=d))
        except PermissionError:
            log_warn(_("æ— æƒé™åˆ é™¤ç›®å½•ï¼š{dir}").format(dir=d))
        except OSError as e:
            log_warn(_("åˆ é™¤ç›®å½•å¤±è´¥ {dir}: {error}").format(dir=d, error=str(e)))
./logging_utils.py


===== FILE: ./logging_utils.py =====

# ===== pylrclibup/logging_utils.pyï¼ˆç§»é™¤ translate å‚æ•°ï¼‰=====

"""
pylrclibup ç»Ÿä¸€æ—¥å¿—æ¨¡å—
"""

from __future__ import annotations

import logging
import sys
from typing import Optional


_logger: Optional[logging.Logger] = None


def get_logger() -> logging.Logger:
    """è·å–æˆ–åˆ›å»ºå…¨å±€ logger å®ä¾‹"""
    global _logger
    if _logger is None:
        _logger = _setup_logger()
    return _logger


def _setup_logger(
    name: str = "pylrclibup",
    level: int = logging.INFO,
) -> logging.Logger:
    """åˆå§‹åŒ–å¹¶é…ç½® logger"""
    logger = logging.getLogger(name)
    
    if logger.handlers:
        return logger
    
    logger.setLevel(level)
    
    stdout_handler = logging.StreamHandler(sys.stdout)
    stdout_handler.setLevel(logging.DEBUG)
    stdout_handler.addFilter(lambda record: record.levelno < logging.ERROR)
    stdout_handler.setFormatter(logging.Formatter("[%(levelname)s] %(message)s"))
    
    stderr_handler = logging.StreamHandler(sys.stderr)
    stderr_handler.setLevel(logging.ERROR)
    stderr_handler.setFormatter(logging.Formatter("[%(levelname)s] %(message)s"))
    
    logger.addHandler(stdout_handler)
    logger.addHandler(stderr_handler)
    logger.propagate = False
    
    return logger


def set_log_level(level: int) -> None:
    """åŠ¨æ€è®¾ç½®æ—¥å¿—çº§åˆ«"""
    get_logger().setLevel(level)


# -------------------- ä¾¿æ·å‡½æ•°ï¼ˆè°ƒç”¨æ–¹éœ€è‡ªè¡Œç¿»è¯‘ï¼‰--------------------


def log_info(msg: str) -> None:
    """è¾“å‡º INFO çº§åˆ«æ—¥å¿—ï¼ˆè°ƒç”¨æ–¹éœ€ä½¿ç”¨ _() åŒ…è£¹ä¸­æ–‡ï¼‰"""
    get_logger().info(msg)


def log_warn(msg: str) -> None:
    """è¾“å‡º WARNING çº§åˆ«æ—¥å¿—ï¼ˆè°ƒç”¨æ–¹éœ€ä½¿ç”¨ _() åŒ…è£¹ä¸­æ–‡ï¼‰"""
    get_logger().warning(msg)


def log_error(msg: str) -> None:
    """è¾“å‡º ERROR çº§åˆ«æ—¥å¿—ï¼ˆè°ƒç”¨æ–¹éœ€ä½¿ç”¨ _() åŒ…è£¹ä¸­æ–‡ï¼‰"""
    get_logger().error(msg)


def log_debug(msg: str) -> None:
    """è¾“å‡º DEBUG çº§åˆ«æ—¥å¿—ï¼ˆè°ƒç”¨æ–¹éœ€ä½¿ç”¨ _() åŒ…è£¹ä¸­æ–‡ï¼‰"""
    get_logger().debug(msg)
