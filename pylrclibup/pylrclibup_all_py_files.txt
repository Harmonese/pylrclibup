./config.py


===== FILE: ./config.py =====

from __future__ import annotations

import os
from dataclasses import dataclass
from pathlib import Path
from typing import Optional


# -------------------- 常量（全局配置） --------------------

# LRCLIB API 根地址
LRCLIB_BASE = "https://lrclib.net/api"

# 预览歌词时显示的最大行数
PREVIEW_LINES_DEFAULT = 10

# HTTP 调用最大自动重试次数
MAX_HTTP_RETRIES_DEFAULT = 5

# 默认 User-Agent（可以在 CLI 里加个选项覆盖）
DEFAULT_USER_AGENT = "pylrclibup (https://github.com/Harmonese/pylrclibup)"


# -------------------- AppConfig --------------------


@dataclass
class AppConfig:
    """
    全局配置对象：

    路径配置：
    - tracks_dir: MP3 输入目录
    - lrc_dir: LRC 输入目录
    - done_tracks_dir: MP3 输出目录（None = 原地不动）
    - done_lrc_dir: LRC 输出目录（None = 原地不动或跟随 MP3）

    行为配置（三个独立的布尔标志）：
    - follow_mp3: LRC 是否跟随 MP3 到同一目录
    - rename_lrc: 处理后是否将 LRC 重命名为与 MP3 同名
    - cleanse_lrc: 处理前是否标准化 LRC 文件

    其他配置：
    - preview_lines: 预览歌词时显示的最大行数
    - max_http_retries: HTTP 自动重试次数
    - user_agent: 发送给 LRCLIB 的 User-Agent
    """

    tracks_dir: Path
    lrc_dir: Path
    done_tracks_dir: Optional[Path]
    done_lrc_dir: Optional[Path]

    follow_mp3: bool = False
    rename_lrc: bool = False
    cleanse_lrc: bool = False

    preview_lines: int = PREVIEW_LINES_DEFAULT
    max_http_retries: int = MAX_HTTP_RETRIES_DEFAULT
    user_agent: str = DEFAULT_USER_AGENT

    lrclib_base: str = LRCLIB_BASE

    # -------------------- 便捷属性（向后兼容） --------------------

    @property
    def pair_lrc_with_track_dir(self) -> bool:
        """向后兼容：-d 模式 = follow + rename + cleanse"""
        return self.follow_mp3 and self.rename_lrc and self.cleanse_lrc

    @property
    def match_mode(self) -> bool:
        """向后兼容：-m 模式 = follow + rename + cleanse"""
        return self.follow_mp3 and self.rename_lrc and self.cleanse_lrc

    @property
    def keep_in_place(self) -> bool:
        """向后兼容：是否为原地模式"""
        return self.done_tracks_dir is None and self.done_lrc_dir is None and not self.follow_mp3

    # -------------------- 工厂方法 --------------------

    @classmethod
    def from_env_and_defaults(
        cls,
        *,
        tracks_dir: Optional[str | Path] = None,
        lrc_dir: Optional[str | Path] = None,
        done_tracks_dir: Optional[str | Path] = None,
        done_lrc_dir: Optional[str | Path] = None,
        follow_mp3: bool = False,
        rename_lrc: bool = False,
        cleanse_lrc: bool = False,
        preview_lines: Optional[int] = None,
        max_http_retries: Optional[int] = None,
        user_agent: Optional[str] = None,
    ) -> "AppConfig":
        """
        统一入口：综合考虑
        1. 显式传入（通常来自 CLI 参数）
        2. 环境变量
        3. 默认值

        优先级：参数 > 环境变量 > 默认
        """
        # 解析输入目录
        tracks, lrc = cls._resolve_input_dirs(tracks_dir, lrc_dir)
        
        # 解析输出目录
        done_tracks, done_lrc = cls._resolve_output_dirs(
            done_tracks_dir, done_lrc_dir
        )
        
        # 解析数值配置
        preview_lines_val, max_retries_val = cls._resolve_numeric_config(
            preview_lines, max_http_retries
        )
        
        # 解析 User-Agent
        ua = user_agent or os.getenv("PYLRCLIBUP_USER_AGENT") or DEFAULT_USER_AGENT

        return cls(
            tracks_dir=tracks,
            lrc_dir=lrc,
            done_tracks_dir=done_tracks,
            done_lrc_dir=done_lrc,
            follow_mp3=follow_mp3,
            rename_lrc=rename_lrc,
            cleanse_lrc=cleanse_lrc,
            preview_lines=preview_lines_val,
            max_http_retries=max_retries_val,
            user_agent=ua,
        )

    @staticmethod
    def _resolve_input_dirs(
        tracks_dir: Optional[str | Path],
        lrc_dir: Optional[str | Path],
    ) -> tuple[Path, Path]:
        """解析输入目录（tracks 和 lrc）"""
        cwd = Path.cwd()
        
        env_tracks = os.getenv("PYLRCLIBUP_TRACKS_DIR")
        env_lrc = os.getenv("PYLRCLIBUP_LRC_DIR")
        
        tracks = Path(tracks_dir or env_tracks or cwd)
        lrc = Path(lrc_dir or env_lrc or cwd)
        
        return tracks, lrc

    @staticmethod
    def _resolve_output_dirs(
        done_tracks_dir: Optional[str | Path],
        done_lrc_dir: Optional[str | Path],
    ) -> tuple[Optional[Path], Optional[Path]]:
        """
        解析输出目录
        
        返回 None 表示原地不动（或跟随 MP3，由 follow_mp3 决定）
        
        Returns:
            (done_tracks, done_lrc)
        """
        env_done_tracks = os.getenv("PYLRCLIBUP_DONE_TRACKS_DIR")
        env_done_lrc = os.getenv("PYLRCLIBUP_DONE_LRC_DIR")
        
        # 设置 done 目录（None 表示原地不动）
        done_tracks = None
        if done_tracks_dir:
            done_tracks = Path(done_tracks_dir)
        elif env_done_tracks:
            done_tracks = Path(env_done_tracks)
        
        done_lrc = None
        if done_lrc_dir:
            done_lrc = Path(done_lrc_dir)
        elif env_done_lrc:
            done_lrc = Path(env_done_lrc)
        
        return done_tracks, done_lrc

    @staticmethod
    def _resolve_numeric_config(
        preview_lines: Optional[int],
        max_http_retries: Optional[int],
    ) -> tuple[int, int]:
        """解析数值类配置"""
        # preview_lines
        if preview_lines is None:
            env_preview = os.getenv("PYLRCLIBUP_PREVIEW_LINES")
            if env_preview and env_preview.isdigit():
                preview_lines_val = int(env_preview)
            else:
                preview_lines_val = PREVIEW_LINES_DEFAULT
        else:
            preview_lines_val = preview_lines
        
        # max_http_retries
        if max_http_retries is None:
            env_retries = os.getenv("PYLRCLIBUP_MAX_HTTP_RETRIES")
            if env_retries and env_retries.isdigit():
                max_retries_val = int(env_retries)
            else:
                max_retries_val = MAX_HTTP_RETRIES_DEFAULT
        else:
            max_retries_val = max_http_retries
        
        return preview_lines_val, max_retries_val
./processor/__init__.py


===== FILE: ./processor/__init__.py =====

"""
处理器模块：核心业务逻辑
"""

from .core import process_all, process_track

__all__ = [
    "process_all",
    "process_track",
]
./processor/core.py


===== FILE: ./processor/core.py =====

# ===== processor/core.py =====

from __future__ import annotations

import sys
from pathlib import Path
from typing import List, Optional

from ..config import AppConfig
from ..model import TrackMeta, LyricsRecord
from ..lrc import find_lrc_for_track, parse_lrc_file, cleanse_lrc_file, ParsedLRC
from ..api import ApiClient, upload_lyrics, upload_instrumental
from ..fs import move_with_dedup, cleanup_empty_dirs
from ..logging_utils import log_info, log_warn, log_error


# -------------------- 预览辅助函数 --------------------


def _preview(label: str, text: str, max_lines: int) -> None:
    """预览歌词内容"""
    print(f"--- {label} ---")
    if not text:
        print("[空]")
        print("-" * 40)
        return
    lines = text.splitlines()
    for ln in lines[:max_lines]:
        print(ln)
    if len(lines) > max_lines:
        print(f"... 共 {len(lines)} 行")
    print("-" * 40)


# -------------------- 文件移动逻辑 --------------------


def move_files_after_processing(
    config: AppConfig,
    meta: TrackMeta,
    lrc_path: Optional[Path],
) -> None:
    """
    处理完成后移动文件的统一逻辑
    """
    # 步骤 1：移动 MP3
    new_mp3_path = meta.path
    
    if config.done_tracks_dir:
        moved_mp3 = move_with_dedup(meta.path, config.done_tracks_dir)
        if moved_mp3:
            new_mp3_path = moved_mp3
            log_info(f"MP3 已移动到：{new_mp3_path}")
        else:
            log_warn("MP3 移动失败，将保持原地")
    
    # 如果没有 LRC 文件，直接返回
    if not lrc_path or not lrc_path.exists():
        cleanup_empty_dirs(config.tracks_dir)
        return
    
    # 步骤 2：确定 LRC 的目标目录
    if config.done_lrc_dir:
        lrc_target_dir = config.done_lrc_dir
    elif config.follow_mp3:
        lrc_target_dir = new_mp3_path.parent
    else:
        lrc_target_dir = lrc_path.parent
    
    # 步骤 3：确定 LRC 的目标文件名
    new_lrc_name = None
    if config.rename_lrc:
        new_lrc_name = new_mp3_path.stem
    
    # 步骤 4：判断是否需要移动
    needs_move = (
        lrc_target_dir != lrc_path.parent or 
        (new_lrc_name and new_lrc_name != lrc_path.stem)
    )
    
    if needs_move:
        new_lrc_path = move_with_dedup(lrc_path, lrc_target_dir, new_name=new_lrc_name)
        if new_lrc_path:
            action = []
            if lrc_target_dir != lrc_path.parent:
                action.append(f"移动到 {lrc_target_dir}")
            if new_lrc_name and new_lrc_name != lrc_path.stem:
                action.append(f"重命名为 {new_lrc_path.name}")
            log_info(f"LRC 已{'、'.join(action)}")
        else:
            log_warn("LRC 移动失败")
    else:
        log_info("LRC 保持原地不动")
    
    # 步骤 5：清理空目录
    cleanup_empty_dirs(config.tracks_dir)
    cleanup_empty_dirs(config.lrc_dir)



# -------------------- 单曲处理辅助函数 --------------------


def _handle_cached_lyrics(
    config: AppConfig,
    meta: TrackMeta,
    cached: LyricsRecord,
) -> None:
    """处理内部数据库已有歌词的情况"""
    log_info("内部数据库已存在歌词 → 自动移动 MP3+LRC 并跳过上传（不再重复提交）")
    _preview("已有 plainLyrics", cached.plain, config.preview_lines)
    _preview("已有 syncedLyrics", cached.synced, config.preview_lines)
    
    lrc_path = find_lrc_for_track(meta, config, interactive=True)
    move_files_after_processing(config, meta, lrc_path)


def _handle_external_lyrics(
    config: AppConfig,
    meta: TrackMeta,
    external: LyricsRecord,
) -> bool:
    """
    处理外部抓取到歌词的情况
    
    Returns:
        True 表示已处理完成（无论成功失败），False 表示用户选择继续本地处理
    """
    plain_ext = external.plain
    synced_ext = external.synced
    instrumental_ext = external.instrumental
    
    log_info("外部抓取到歌词（仅供参考，可选择是否直接使用外部版本上传）：")
    _preview("外部 plainLyrics", plain_ext, config.preview_lines)
    _preview("外部 syncedLyrics", synced_ext, config.preview_lines)
    
    if instrumental_ext:
        log_info("外部记录中该曲被标记为 instrumental（或两种歌词字段均为空）。")
    
    # 始终询问用户
    choice = input("是否直接使用外部版本上传？[y/N]: ").strip().lower()
    use_ext = choice in ("y", "yes")
    
    if not use_ext:
        log_info("用户选择不直接使用外部歌词 → 继续尝试本地 LRC。")
        return False
    
    # 执行上传
    if instrumental_ext:
        log_info("将使用“纯音乐”方式上传（不包含任何歌词内容，只标记为 instrumental）。")
        ok = upload_instrumental(config, meta)
    else:
        log_info("将直接使用外部 plain+synced 歌词上传。")
        ok = upload_lyrics(config, meta, plain_ext, synced_ext)
    
    if ok:
        log_info("外部歌词上传完成 ✓")
        lrc_path = find_lrc_for_track(meta, config, interactive=True)
        move_files_after_processing(config, meta, lrc_path)
    else:
        log_error("外部歌词上传失败 ×")
    
    return True


def _prompt_for_missing_lrc(
    config: AppConfig,
    meta: TrackMeta,
) -> Optional[Path]:
    """
    当未找到本地 LRC 时，提示用户选择操作
    
    Returns:
        手动指定的 LRC 路径，或 None（跳过/退出/标记纯音乐）
    """
    while True:
        choice = input(
            "未找到本地 LRC，选择 "
            "[s] 跳过该歌曲 / "
            "[m] 手动指定歌词文件 / "
            "[i] 上传空歌词标记为纯音乐 / "
            "[q] 退出程序: "
        ).strip().lower()
        
        if choice == "s":
            log_info("跳过该歌曲，不上传、不移动。")
            return None
        
        elif choice == "m":
            lrc_path = _get_manual_lrc_path()
            if lrc_path:
                return lrc_path
            # 路径无效，继续循环
        
        elif choice == "i":
            log_info("将上传空歌词（标记为纯音乐）。")
            ok = upload_instrumental(config, meta)
            if ok:
                log_info("纯音乐标记上传完成 ✓")
                move_files_after_processing(config, meta, lrc_path=None)
            else:
                log_error("纯音乐标记上传失败 ×")
            return None
        
        elif choice == "q":
            log_info("用户选择退出程序。")
            sys.exit(1)
        
        else:
            print("无效输入，请重新选择。")


def _get_manual_lrc_path() -> Optional[Path]:
    """获取用户手动输入的 LRC 文件路径"""
    manual_path_raw = input("请输入 LRC 文件的完整路径: ").strip()
    
    if not manual_path_raw:
        print("路径为空，请重新选择。")
        return None
    
    # 处理引号（单引号/双引号）
    if (manual_path_raw.startswith("'") and manual_path_raw.endswith("'")) or \
       (manual_path_raw.startswith('"') and manual_path_raw.endswith('"')):
        manual_path_raw = manual_path_raw[1:-1]
    
    # 处理路径：支持绝对路径和相对路径
    lrc_path = Path(manual_path_raw).expanduser()
    
    if not lrc_path.is_absolute():
        lrc_path = Path.cwd() / lrc_path
    
    lrc_path = lrc_path.resolve()
    
    if not lrc_path.exists() or not lrc_path.is_file():
        print(f"文件不存在或不是有效文件：{lrc_path}")
        return None
    
    if lrc_path.suffix.lower() != ".lrc":
        confirm = input(f"警告：文件扩展名不是 .lrc，是否继续？[y/N]: ").strip().lower()
        if confirm not in ("y", "yes"):
            return None
    
    log_info(f"使用手动指定的歌词文件：{lrc_path}")
    return lrc_path


def _upload_local_lyrics(
    config: AppConfig,
    meta: TrackMeta,
    lrc_path: Path,
    parsed: ParsedLRC,
) -> None:
    """上传本地解析的歌词"""
    treat_as_instrumental = parsed.is_instrumental or (
        not parsed.plain.strip() and not parsed.synced.strip()
    )
    
    if treat_as_instrumental:
        log_info("根据解析结果：将按纯音乐曲目上传。")
        choice = input("确认以纯音乐方式上传？[y/N]: ").strip().lower()
        if choice not in ("y", "yes"):
            log_info("用户取消上传。")
            return
        
        ok = upload_instrumental(config, meta)
        if ok:
            log_info("纯音乐上传完成 ✓")
            move_files_after_processing(config, meta, lrc_path)
        else:
            log_error("纯音乐上传失败 ×")
        return
    
    # 非纯音乐 → 正常上传 plain+synced
    choice = input("确认上传本地歌词？[y/N]: ").strip().lower()
    if choice not in ("y", "yes"):
        log_info("用户取消上传。")
        return
    
    ok = upload_lyrics(config, meta, parsed.plain, parsed.synced)
    if ok:
        log_info("上传完成 ✓")
        move_files_after_processing(config, meta, lrc_path)
    else:
        log_error("上传失败 ×")


# -------------------- 单曲处理逻辑 --------------------


# ===== processor/core.py =====

def process_track(
    config: AppConfig,
    api_client: ApiClient,
    meta: TrackMeta,
) -> None:
    """
    处理一首歌：
      1. 查找本地 LRC
      2. [可选] 标准化 LRC（如果 config.cleanse_lrc=True）
      3. /api/get-cached 查内部数据库
      4. /api/get 查外部歌词（可选用）
      5. LRC 解析
      6. 上传（歌词 / 纯音乐）
      7. 移动文件 & 清理空目录
    """
    log_info(f"处理：{meta}")

    # 1. 查找本地 LRC 文件
    lrc_path = find_lrc_for_track(meta, config, interactive=True)
    
    if not lrc_path:
        log_warn(f"⚠ 未找到本地 LRC 文件：{meta.track}")
        lrc_path = _prompt_for_missing_lrc(config, meta)
        if not lrc_path:
            return
    
    # 2. [可选] 标准化 LRC 文件（在处理开始前）
    if config.cleanse_lrc:
        log_info(f"正在标准化 LRC 文件：{lrc_path.name}")
        if cleanse_lrc_file(lrc_path):
            log_info("✓ LRC 文件已标准化")
        else:
            log_warn("⚠ LRC 文件标准化失败，将继续使用原始内容")

    # 3. 先查内部数据库（不触发外部抓取）
    cached: Optional[LyricsRecord] = api_client.get_cached(meta)
    if cached:
        _handle_cached_lyrics(config, meta, cached)
        return

    # 4. 再查外部抓取（仅供参考，可选是否直接使用）
    external: Optional[LyricsRecord] = api_client.get_external(meta)
    if external:
        handled = _handle_external_lyrics(config, meta, external)
        if handled:
            return

    # 5. 解析本地 LRC（已经标准化过了，直接读取）
    parsed: ParsedLRC = parse_lrc_file(lrc_path)

    if parsed.is_instrumental:
        log_info("LRC 中检测到“纯音乐，请欣赏”等字样，将按纯音乐处理（不上传歌词内容）。")

    _preview("本地 plainLyrics（将上传）", parsed.plain, config.preview_lines)
    _preview("本地 syncedLyrics（将上传）", parsed.synced, config.preview_lines)

    # 6. 上传歌词
    _upload_local_lyrics(config, meta, lrc_path, parsed)


# -------------------- 批量处理 --------------------


def process_all(config: AppConfig) -> None:
    """
    入口函数：递归扫描 tracks_dir 下所有 .mp3

    CLI 层只需要调用这一层。
    """
    api_client = ApiClient(config)

    metas: List[TrackMeta] = []
    
    for p in sorted(config.tracks_dir.rglob("*.mp3")):
        tm = TrackMeta.from_mp3(p)
        if tm:
            metas.append(tm)

    total = len(metas)
    for idx, meta in enumerate(metas, 1):
        log_info(f"[{idx}/{total}] 开始处理...")
        process_track(config, api_client, meta)
        print()

    log_info("全部完成。")
./tests/test_matcher.py


===== FILE: ./tests/test_matcher.py =====

"""
LRC 匹配器单元测试
"""

import pytest
from pathlib import Path
from pylrclibup.lrc.matcher import (
    split_artists,
    match_artists,
    parse_lrc_filename,
)


class TestSplitArtists:
    """测试 split_artists 函数"""
    
    def test_single_artist(self):
        assert split_artists("Artist") == ["artist"]
    
    def test_feat_separator(self):
        result = split_artists("Artist A feat. Artist B")
        assert "artist a" in result
        assert "artist b" in result
    
    def test_featuring_separator(self):
        result = split_artists("Artist A featuring Artist B")
        assert "artist a" in result
        assert "artist b" in result
    
    def test_ampersand_separator(self):
        result = split_artists("Artist A & Artist B")
        assert "artist a" in result
        assert "artist b" in result
    
    def test_chinese_separator(self):
        result = split_artists("艺术家A和艺术家B")
        assert "艺术家a" in result
        assert "艺术家b" in result
    
    def test_comma_separator(self):
        result = split_artists("A,B,C")
        assert len(result) == 3
    
    def test_x_separator(self):
        result = split_artists("Artist A x Artist B")
        assert "artist a" in result
        assert "artist b" in result
    
    def test_mixed_separators(self):
        result = split_artists("A & B feat. C / D")
        assert len(result) == 4
    
    def test_dedup(self):
        result = split_artists("A & A & B")
        assert result.count("a") == 1


class TestMatchArtists:
    """测试 match_artists 函数"""
    
    def test_exact_match(self):
        assert match_artists(["artist"], ["artist"]) is True
    
    def test_partial_match(self):
        assert match_artists(["a", "b"], ["b", "c"]) is True
    
    def test_no_match(self):
        assert match_artists(["a", "b"], ["c", "d"]) is False
    
    def test_case_insensitive(self):
        assert match_artists(["Artist"], ["ARTIST"]) is True
    
    def test_empty_lists(self):
        assert match_artists([], []) is False
        assert match_artists(["a"], []) is False


class TestParseLrcFilename:
    """测试 parse_lrc_filename 函数"""
    
    def test_standard_format(self, tmp_path: Path):
        lrc = tmp_path / "Artist - Song.lrc"
        lrc.touch()
        
        artists, title = parse_lrc_filename(lrc)
        
        assert "artist" in artists
        assert title == "song"
    
    def test_multiple_artists(self, tmp_path: Path):
        lrc = tmp_path / "A & B - Song.lrc"
        lrc.touch()
        
        artists, title = parse_lrc_filename(lrc)
        
        assert "a" in artists
        assert "b" in artists
        assert title == "song"
    
    def test_no_separator(self, tmp_path: Path):
        lrc = tmp_path / "SongWithoutArtist.lrc"
        lrc.touch()
        
        artists, title = parse_lrc_filename(lrc)
        
        assert artists == []
        assert title == ""
    
    def test_multiple_separators(self, tmp_path: Path):
        lrc = tmp_path / "Artist - Song - Remix.lrc"
        lrc.touch()
        
        artists, title = parse_lrc_filename(lrc)
        
        assert "artist" in artists
        assert title == "song - remix"
./tests/conftest.py


===== FILE: ./tests/conftest.py =====

"""
pytest 共享 fixtures
"""

import pytest
from pathlib import Path


@pytest.fixture
def sample_lrc_content() -> str:
    """标准 LRC 文件内容样例"""
    return """[ti:测试歌曲]
[ar:测试艺术家]
[al:测试专辑]
[00:00.00]作词：张三
[00:01.00]作曲：李四
[00:02.00]第一行歌词
[00:05.00]第二行歌词
[00:10.00]第三行歌词
"""


@pytest.fixture
def sample_instrumental_lrc() -> str:
    """纯音乐 LRC 样例"""
    return """[00:00.00]纯音乐，请欣赏
"""


@pytest.fixture
def sample_lrc_with_translation() -> str:
    """带翻译的 LRC 样例"""
    return """[00:00.00]Hello world
[00:00.00]你好世界
[00:05.00]Goodbye
[00:05.00]再见
"""


@pytest.fixture
def create_lrc_file(tmp_path: Path):
    """创建临时 LRC 文件的工厂函数"""
    def _create(name: str, content: str) -> Path:
        lrc = tmp_path / name
        lrc.write_text(content, encoding='utf-8')
        return lrc
    return _create
./tests/__init__.py


===== FILE: ./tests/__init__.py =====

"""pylrclibup 测试模块"""
./tests/test_lrc_parser.py


===== FILE: ./tests/test_lrc_parser.py =====

"""
LRC 解析器单元测试
"""

import pytest
from pathlib import Path
from pylrclibup.lrc.parser import (
    normalize_name,
    parse_lrc_file,
    ParsedLRC,
    TIMESTAMP_RE,
)


class TestNormalizeName:
    """测试 normalize_name 函数"""
    
    def test_basic_strip_and_lowercase(self):
        assert normalize_name("  Hello World  ") == "hello world"
    
    def test_fullwidth_punctuation(self):
        assert normalize_name("（测试）") == "(测试)"
        assert normalize_name("【标题】") == "[标题]"
        assert normalize_name("歌曲：名称") == "歌曲:名称"
    
    def test_cyrillic_mapping(self):
        assert normalize_name("Привёт") == "привет"
        assert normalize_name("Ёлка") == "елка"
    
    def test_multiple_spaces(self):
        assert normalize_name("hello    world") == "hello world"
    
    def test_empty_string(self):
        assert normalize_name("") == ""
    
    def test_unicode_normalization(self):
        # 全角字母应转为半角
        assert normalize_name("Ａｂｃ") == "abc"


class TestTimestampRegex:
    """测试时间戳正则表达式"""
    
    def test_standard_timestamp(self):
        assert TIMESTAMP_RE.match("[00:00.00]")
        assert TIMESTAMP_RE.match("[01:23.45]")
        assert TIMESTAMP_RE.match("[99:59.999]")
    
    def test_invalid_timestamp(self):
        assert not TIMESTAMP_RE.match("[0:00.00]")
        assert not TIMESTAMP_RE.match("[00:00]")
        assert not TIMESTAMP_RE.match("00:00.00")


class TestParseLrcFile:
    """测试 parse_lrc_file 函数"""
    
    def test_instrumental_detection(self, tmp_path: Path):
        lrc = tmp_path / "test.lrc"
        lrc.write_text("[00:00.00]纯音乐，请欣赏\n[00:01.00]歌词内容")
        
        result = parse_lrc_file(lrc)
        
        assert result.is_instrumental is True
        assert "纯音乐" not in result.synced
    
    def test_credit_removal(self, tmp_path: Path):
        lrc = tmp_path / "test.lrc"
        lrc.write_text(
            "[00:00.00]作词：张三\n"
            "[00:01.00]作曲：李四\n"
            "[00:02.00]这是歌词\n"
        )
        
        result = parse_lrc_file(lrc)
        
        assert "作词" not in result.synced
        assert "作曲" not in result.synced
        assert "这是歌词" in result.plain
    
    def test_empty_file(self, tmp_path: Path):
        lrc = tmp_path / "empty.lrc"
        lrc.write_text("")
        
        result = parse_lrc_file(lrc)
        
        assert result.synced == ""
        assert result.plain == ""
        assert result.is_instrumental is False
    
    def test_no_timestamp(self, tmp_path: Path):
        lrc = tmp_path / "no_ts.lrc"
        lrc.write_text("这不是有效的 LRC 文件")
        
        result = parse_lrc_file(lrc)
        
        assert result.synced == ""
        assert result.plain == ""
    
    def test_header_removal(self, tmp_path: Path):
        lrc = tmp_path / "header.lrc"
        lrc.write_text(
            "[ti:歌曲名]\n"
            "[ar:艺术家]\n"
            "[00:00.00]第一行歌词\n"
            "[00:05.00]第二行歌词\n"
        )
        
        result = parse_lrc_file(lrc)
        
        # 头部标签应被跳过
        assert "[ti:" not in result.synced
        assert "[ar:" not in result.synced
        assert "第一行歌词" in result.plain
    
    def test_translation_removal(self, tmp_path: Path):
        lrc = tmp_path / "trans.lrc"
        lrc.write_text(
            "[00:00.00]Hello world\n"
            "[00:00.00]你好世界\n"
            "[00:05.00]Goodbye\n"
        )
        
        result = parse_lrc_file(lrc, remove_translations=True)
        
        # 同一时间戳的中文行应被移除
        assert "Hello world" in result.plain
        assert "你好世界" not in result.plain
        assert "Goodbye" in result.plain
    
    def test_keep_translations(self, tmp_path: Path):
        lrc = tmp_path / "trans.lrc"
        lrc.write_text(
            "[00:00.00]Hello world\n"
            "[00:00.00]你好世界\n"
        )
        
        result = parse_lrc_file(lrc, remove_translations=False)
        
        assert "Hello world" in result.plain
        assert "你好世界" in result.plain
./tests/test_fs.py


===== FILE: ./tests/test_fs.py =====

"""
文件系统操作单元测试
"""

import pytest
from pathlib import Path
from pylrclibup.fs.mover import move_with_dedup
from pylrclibup.fs.cleaner import cleanup_empty_dirs


class TestMoveWithDedup:
    """测试 move_with_dedup 函数"""
    
    def test_basic_move(self, tmp_path: Path):
        src = tmp_path / "src" / "file.txt"
        dst_dir = tmp_path / "dst"
        
        src.parent.mkdir(parents=True)
        src.write_text("content")
        
        result = move_with_dedup(src, dst_dir)
        
        assert result is not None
        assert result.exists()
        assert result.name == "file.txt"
        assert not src.exists()
    
    def test_dedup_on_conflict(self, tmp_path: Path):
        src = tmp_path / "src" / "file.txt"
        dst_dir = tmp_path / "dst"
        existing = dst_dir / "file.txt"
        
        src.parent.mkdir(parents=True)
        dst_dir.mkdir(parents=True)
        src.write_text("new content")
        existing.write_text("existing content")
        
        result = move_with_dedup(src, dst_dir)
        
        assert result is not None
        assert result.name == "file_dup1.txt"
        assert existing.exists()
    
    def test_multiple_dedup(self, tmp_path: Path):
        src = tmp_path / "src" / "file.txt"
        dst_dir = tmp_path / "dst"
        
        src.parent.mkdir(parents=True)
        dst_dir.mkdir(parents=True)
        
        # 创建已存在的重名文件
        (dst_dir / "file.txt").write_text("1")
        (dst_dir / "file_dup1.txt").write_text("2")
        
        src.write_text("new")
        result = move_with_dedup(src, dst_dir)
        
        assert result is not None
        assert result.name == "file_dup2.txt"
    
    def test_rename_on_move(self, tmp_path: Path):
        src = tmp_path / "src" / "original.lrc"
        dst_dir = tmp_path / "dst"
        
        src.parent.mkdir(parents=True)
        src.write_text("lyrics")
        
        result = move_with_dedup(src, dst_dir, new_name="new_name")
        
        assert result is not None
        assert result.name == "new_name.lrc"
    
    def test_same_location_no_op(self, tmp_path: Path):
        file = tmp_path / "file.txt"
        file.write_text("content")
        
        result = move_with_dedup(file, tmp_path)
        
        assert result == file
        assert file.exists()


class TestCleanupEmptyDirs:
    """测试 cleanup_empty_dirs 函数"""
    
    def test_remove_empty_dirs(self, tmp_path: Path):
        empty_dir = tmp_path / "a" / "b" / "c"
        empty_dir.mkdir(parents=True)
        
        cleanup_empty_dirs(tmp_path)
        
        assert not (tmp_path / "a").exists()
    
    def test_keep_non_empty_dirs(self, tmp_path: Path):
        non_empty = tmp_path / "a" / "b"
        non_empty.mkdir(parents=True)
        (non_empty / "file.txt").write_text("content")
        
        cleanup_empty_dirs(tmp_path)
        
        assert non_empty.exists()
        assert (non_empty / "file.txt").exists()
    
    def test_keep_root(self, tmp_path: Path):
        cleanup_empty_dirs(tmp_path)
        
        assert tmp_path.exists()
    
    def test_mixed_dirs(self, tmp_path: Path):
        # 创建混合结构
        (tmp_path / "empty1" / "empty2").mkdir(parents=True)
        (tmp_path / "nonempty").mkdir(parents=True)
        (tmp_path / "nonempty" / "file.txt").write_text("x")
        
        cleanup_empty_dirs(tmp_path)
        
        assert not (tmp_path / "empty1").exists()
        assert (tmp_path / "nonempty").exists()
./tests/test_config.py


===== FILE: ./tests/test_config.py =====

# ===== tests/test_config.py =====

"""
配置模块单元测试
"""

import pytest
import os
from pathlib import Path
from pylrclibup.config import AppConfig


class TestAppConfig:
    """测试 AppConfig 类"""
    
    def test_default_values(self, tmp_path: Path, monkeypatch):
        # 清除环境变量
        monkeypatch.delenv("PYLRCLIBUP_TRACKS_DIR", raising=False)
        monkeypatch.delenv("PYLRCLIBUP_LRC_DIR", raising=False)
        monkeypatch.delenv("PYLRCLIBUP_DONE_TRACKS_DIR", raising=False)
        monkeypatch.delenv("PYLRCLIBUP_DONE_LRC_DIR", raising=False)
        
        monkeypatch.chdir(tmp_path)
        
        config = AppConfig.from_env_and_defaults()
        
        assert config.tracks_dir == tmp_path
        assert config.lrc_dir == tmp_path
        assert config.done_tracks_dir is None
        assert config.done_lrc_dir is None
        assert config.follow_mp3 is False
        assert config.rename_lrc is False
        assert config.cleanse_lrc is False
        assert config.preview_lines == 10
        assert config.max_http_retries == 5
    
    def test_explicit_dirs(self, tmp_path: Path):
        tracks = tmp_path / "tracks"
        lrc = tmp_path / "lrc"
        done_tracks = tmp_path / "done_tracks"
        done_lrc = tmp_path / "done_lrc"
        
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tracks,
            lrc_dir=lrc,
            done_tracks_dir=done_tracks,
            done_lrc_dir=done_lrc,
        )
        
        assert config.tracks_dir == tracks
        assert config.lrc_dir == lrc
        assert config.done_tracks_dir == done_tracks
        assert config.done_lrc_dir == done_lrc
    
    def test_follow_mode(self, tmp_path: Path):
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            follow_mp3=True,
        )
        
        assert config.follow_mp3 is True
    
    def test_rename_mode(self, tmp_path: Path):
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            rename_lrc=True,
        )
        
        assert config.rename_lrc is True
    
    def test_cleanse_mode(self, tmp_path: Path):
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            cleanse_lrc=True,
        )
        
        assert config.cleanse_lrc is True
    
    def test_combined_modes(self, tmp_path: Path):
        # 测试 -d 模式（follow + rename + cleanse）
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            follow_mp3=True,
            rename_lrc=True,
            cleanse_lrc=True,
        )
        
        assert config.follow_mp3 is True
        assert config.rename_lrc is True
        assert config.cleanse_lrc is True
    
    def test_backward_compatibility_pair_mode(self, tmp_path: Path):
        # -d 模式的向后兼容属性
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            follow_mp3=True,
            rename_lrc=True,
            cleanse_lrc=True,
        )
        
        assert config.pair_lrc_with_track_dir is True
    
    def test_backward_compatibility_match_mode(self, tmp_path: Path):
        # -m 模式的向后兼容属性
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
            follow_mp3=True,
            rename_lrc=True,
            cleanse_lrc=True,
        )
        
        assert config.match_mode is True
    
    def test_backward_compatibility_keep_in_place(self, tmp_path: Path):
        # 原地模式的向后兼容属性
        config = AppConfig.from_env_and_defaults(
            tracks_dir=tmp_path,
            lrc_dir=tmp_path,
        )
        
        assert config.keep_in_place is True
    
    def test_env_override(self, tmp_path: Path, monkeypatch):
        env_tracks = tmp_path / "env_tracks"
        monkeypatch.setenv("PYLRCLIBUP_TRACKS_DIR", str(env_tracks))
        
        config = AppConfig.from_env_and_defaults()
        
        assert config.tracks_dir == env_tracks
    
    def test_explicit_overrides_env(self, tmp_path: Path, monkeypatch):
        env_tracks = tmp_path / "env_tracks"
        explicit_tracks = tmp_path / "explicit_tracks"
        
        monkeypatch.setenv("PYLRCLIBUP_TRACKS_DIR", str(env_tracks))
        
        config = AppConfig.from_env_and_defaults(tracks_dir=explicit_tracks)
        
        assert config.tracks_dir == explicit_tracks
./__init__.py


===== FILE: ./__init__.py =====

# ===== __init__.py =====

"""
pylrclibup

A tool to upload local LRC lyrics / instrumental markers to LRCLIB.net,
based on track metadata from your music library (e.g. Jellyfin + MusicBrainz Picard).
"""

from .config import AppConfig
from .logging_utils import get_logger, set_log_level, log_info, log_warn, log_error

__all__ = [
    "AppConfig",
    "get_logger",
    "set_log_level",
    "log_info",
    "log_warn",
    "log_error",
]

__version__ = "0.3.0"./cli/__init__.py


===== FILE: ./cli/__init__.py =====

"""
CLI 模块
"""

from .main import run_cli

__all__ = ["run_cli"]
./cli/main.py


===== FILE: ./cli/main.py =====

from __future__ import annotations

import argparse
import sys
from pathlib import Path

from ..config import AppConfig
from ..processor import process_all
from ..logging_utils import log_info, log_error


def validate_args(args) -> None:
    """
    验证命令行参数的冲突规则
    
    规则：
    1. --follow + --done-lrc 显式指定 → 错误
    2. -d 不能与 -m 同时使用 → 错误
    3. -d/-m 不能与 -f/-r/-c 同时使用 → 错误
    4. -d/-m 不能与路径参数同时使用 → 错误
    """
    # 规则 1：--follow 与 --done-lrc 冲突
    if args.follow and args.done_lrc:
        log_error("错误：--follow 与 --done-lrc 不能同时使用")
        log_error("提示：--follow 表示 LRC 跟随 MP3，不应指定独立的 LRC 输出目录")
        sys.exit(1)
    
    # 规则 2：-d 与 -m 冲突
    if args.default and args.match:
        log_error("错误：-d/--default 与 -m/--match 不能同时使用")
        sys.exit(1)
    
    # 规则 3 & 4：快捷模式与其他参数冲突
    if args.default:
        conflicts = []
        if args.follow:
            conflicts.append("-f/--follow")
        if args.rename:
            conflicts.append("-r/--rename")
        if args.cleanse:
            conflicts.append("-c/--cleanse")
        if args.tracks or args.lrc or args.done_tracks or args.done_lrc:
            conflicts.append("路径参数")
        
        if conflicts:
            log_error(f"错误：-d/--default 模式不能与以下参数同时使用：{', '.join(conflicts)}")
            sys.exit(1)
    
    if args.match:
        conflicts = []
        if args.follow:
            conflicts.append("-f/--follow")
        if args.rename:
            conflicts.append("-r/--rename")
        if args.cleanse:
            conflicts.append("-c/--cleanse")
        
        if conflicts:
            log_error(f"错误：-m/--match 模式不能与以下参数同时使用：{', '.join(conflicts)}")
            sys.exit(1)


def run_cli():
    """
    pylrclibup 的命令行入口点。
    """

    parser = argparse.ArgumentParser(
        prog="pylrclibup",
        description="Upload lyrics or instrumental tags to LRCLIB with local files."
    )

    # -------------------- 路径参数 --------------------
    parser.add_argument("--tracks", type=str,
                        help="歌曲文件输入目录（默认：当前工作目录）")
    parser.add_argument("--lrc", type=str,
                        help="LRC 文件输入目录（默认：当前工作目录）")
    parser.add_argument("--done-tracks", type=str,
                        help="处理后歌曲文件移动到的目录（默认：原地不动）")
    parser.add_argument("--done-lrc", type=str,
                        help="处理后 LRC 文件移动到的目录（默认：原地不动或跟随 MP3）")

    # -------------------- 行为控制参数 --------------------
    parser.add_argument("-f", "--follow", action="store_true",
                        help="LRC 文件跟随 MP3 到同一目录（与 --done-lrc 冲突）")
    parser.add_argument("-r", "--rename", action="store_true",
                        help="处理后将 LRC 重命名为与 MP3 同名")
    parser.add_argument("-c", "--cleanse", action="store_true",
                        help="处理前标准化 LRC 文件（移除 credit、翻译等）")

    # -------------------- 其他参数 --------------------
    parser.add_argument("--preview-lines", type=int, default=10,
                        help="预览歌词时显示的行数")

    # -------------------- 快捷模式 --------------------
    parser.add_argument(
        "-d", "--default",
        nargs=2,
        metavar=("TRACKS_DIR", "LRC_DIR"),
        help=(
            "快捷模式：等价于 --tracks TRACKS_DIR --lrc LRC_DIR --follow --rename --cleanse。"
            "歌曲文件保持原地不动，LRC 移动到对应歌曲目录并重命名，且会标准化 LRC 文件。"
        ),
    )

    parser.add_argument(
        "-m", "--match",
        action="store_true",
        help=(
            "匹配模式：等价于 --follow --rename --cleanse。"
            "处理完成后，LRC 移动到 MP3 所在目录并重命名为与歌曲文件相同的名称，且会标准化 LRC 文件。"
        ),
    )

    args = parser.parse_args()

    # ========== 参数冲突检查 ==========
    validate_args(args)

    # ========== 统一处理所有模式 ==========
    
    # 处理 -d/--default 模式（转换为普通参数）
    if args.default:
        tracks_arg, lrc_arg = args.default
        
        tracks_dir = Path(tracks_arg).resolve()
        lrc_dir = Path(lrc_arg).resolve()
        done_tracks_dir = None  # 原地不动
        done_lrc_dir = None     # 跟随 MP3
        follow_mp3 = True
        rename_lrc = True
        cleanse_lrc = True
    
    # 处理 -m/--match 模式
    elif args.match:
        tracks_dir = Path(args.tracks).resolve() if args.tracks else None
        lrc_dir = Path(args.lrc).resolve() if args.lrc else None
        done_tracks_dir = Path(args.done_tracks).resolve() if args.done_tracks else None
        done_lrc_dir = None  # match 模式下 LRC 跟随 MP3
        follow_mp3 = True
        rename_lrc = True
        cleanse_lrc = True
    
    # 普通模式
    else:
        tracks_dir = Path(args.tracks).resolve() if args.tracks else None
        lrc_dir = Path(args.lrc).resolve() if args.lrc else None
        done_tracks_dir = Path(args.done_tracks).resolve() if args.done_tracks else None
        done_lrc_dir = Path(args.done_lrc).resolve() if args.done_lrc else None
        follow_mp3 = args.follow
        rename_lrc = args.rename
        cleanse_lrc = args.cleanse

    # 统一创建配置
    config = AppConfig.from_env_and_defaults(
        tracks_dir=tracks_dir,
        lrc_dir=lrc_dir,
        done_tracks_dir=done_tracks_dir,
        done_lrc_dir=done_lrc_dir,
        follow_mp3=follow_mp3,
        rename_lrc=rename_lrc,
        cleanse_lrc=cleanse_lrc,
        preview_lines=args.preview_lines,
    )

    # 执行处理
    try:
        process_all(config)
    except KeyboardInterrupt:
        print("\n[INFO] 用户中断执行（Ctrl+C），已优雅退出。")
        sys.exit(0)
./lrc/matcher.py


===== FILE: ./lrc/matcher.py =====

from __future__ import annotations

from pathlib import Path
from typing import List, Optional, Tuple
import re

from ..config import AppConfig
from ..model import TrackMeta
from .parser import normalize_name


# -------------------- 艺人拆分 & 匹配 --------------------


def split_artists(s: str) -> List[str]:
    """
    将艺人字符串拆分成多个 artist
    """
    s = s.lower()
    
    # 处理 feat/featuring
    s = re.sub(r'\bfeat\.?\s+', '<<<SEP>>>', s)
    s = re.sub(r'\bfeaturing\b', '<<<SEP>>>', s)
    
    # 拆分半角逗号
    s = re.sub(r'(?<!\s),(?!\s)', '<<<SEP>>>', s)
    
    # 处理其他分隔符
    for sep in [" x ", " X ", "×"]:
        s = s.replace(sep, '<<<SEP>>>')
    
    for sep in ["&", "和", "/", ";", "、", "，", "､"]:
        s = s.replace(sep, '<<<SEP>>>')
    
    artists = [a.strip() for a in s.split('<<<SEP>>>') if a.strip()]
    
    return list(dict.fromkeys(artists))


def match_artists(mp3_artists: List[str], lrc_artists: List[str]) -> bool:
    """艺人匹配策略"""
    mp3_norm = {normalize_name(a) for a in mp3_artists}
    lrc_norm = {normalize_name(a) for a in lrc_artists}
    return not mp3_norm.isdisjoint(lrc_norm)


# -------------------- LRC 文件名解析 & 匹配 --------------------


def parse_lrc_filename(path: Path) -> Tuple[List[str], str]:
    """从 LRC 文件名解析出 (artists_list, title_norm)"""
    stem = path.stem
    if " - " not in stem:
        return [], ""
    artist_raw, title_raw = stem.split(" - ", 1)
    artists = split_artists(artist_raw)
    title = normalize_name(title_raw)
    return artists, title


def find_lrc_for_track(
    meta: TrackMeta,
    config: AppConfig,
    *,
    interactive: bool = True,
) -> Optional[Path]:
    """
    在 config.lrc_dir 下递归寻找和某首歌曲匹配的 LRC 文件
    """
    meta_title_norm = normalize_name(meta.track)
    meta_artists = split_artists(meta.artist)

    candidates: List[Path] = []

    for p in config.lrc_dir.rglob("*.lrc"):
        lrc_artists, lrc_title_norm = parse_lrc_filename(p)
        if not lrc_title_norm:
            continue

        if lrc_title_norm != meta_title_norm:
            continue

        if match_artists(meta_artists, lrc_artists):
            candidates.append(p)

    if not candidates:
        return None

    if len(candidates) == 1 or not interactive:
        return candidates[0]

    # 多个候选 → 交互选择
    print("\n匹配到多个歌词文件，请选择：")
    for idx, c in enumerate(candidates, 1):
        print(f"{idx}) {c}")

    while True:
        choice = input(f"请输入 1-{len(candidates)}: ").strip()
        if choice.isdigit():
            i = int(choice)
            if 1 <= i <= len(candidates):
                return candidates[i - 1]
        print("输入无效，请重新输入。")
./lrc/__init__.py


===== FILE: ./lrc/__init__.py =====

# ===== lrc/__init__.py =====

"""
LRC 模块：解析和匹配歌词文件
"""

from .parser import parse_lrc_file, write_lrc_file, cleanse_lrc_file, ParsedLRC, normalize_name
from .matcher import find_lrc_for_track, split_artists, match_artists

__all__ = [
    "parse_lrc_file",
    "write_lrc_file",
    "cleanse_lrc_file",
    "ParsedLRC",
    "normalize_name",
    "find_lrc_for_track",
    "split_artists",
    "match_artists",
]
./lrc/parser.py


===== FILE: ./lrc/parser.py =====

# ===== lrc/parser.py =====

from __future__ import annotations

import re
import unicodedata
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional

from ..logging_utils import log_warn, log_error


# -------------------- 文本规范化 --------------------


def normalize_name(s: str) -> str:
    """
    增强版规范化：支持多语言
    """
    s = s.strip().lower()
    
    # Unicode 规范化
    s = unicodedata.normalize('NFKC', s)
    
    # 西里尔字母映射
    cyrillic_map = {
        'ё': 'е',
        'і': 'и',
        'ї': 'и',
        'є': 'е',
        'ґ': 'г',
    }
    for old, new in cyrillic_map.items():
        s = s.replace(old, new)
    
    # 全角标点替换
    replacements = {
        "（": "(",
        "）": ")",
        "【": "[",
        "】": "]",
        "：": ":",
        "。": ".",
        "，": ",",
        "！": "!",
        "？": "?",
        "＆": "&",
        "／": "/",
        "；": ";",
    }
    for k, v in replacements.items():
        s = s.replace(k, v)
    
    # 移除零宽字符和控制字符（保留空格）
    s = ''.join(ch for ch in s if unicodedata.category(ch)[0] not in ('C', 'Z') or ch == ' ')
    
    # 合并多余空格
    s = re.sub(r"\s+", " ", s)
    return s.strip()


# -------------------- LRC 内容解析 --------------------

# 标准时间标签
TIMESTAMP_RE = re.compile(r"\[\d{2}:\d{2}\.\d{2,3}\]")

# 扩展时间标签
EXTENDED_TIMESTAMP_RE = re.compile(r"\[\d{2}:\d{2}(?:\.\d{1,3}(?:-\d{1,3})?)?\]")

# LRC 头部标签
HEADER_TAG_RE = re.compile(r"^\[[a-zA-Z]{2,3}:.+\]$")

# NCM 常见 credit 关键字
CREDIT_KEYWORDS = (
    "作词", "作曲", "编曲", "混音", "缩混", "录音", "母带", "制作", "监制", "和声", 
    "配唱", "制作人", "演唱", "伴奏", "编配", "吉他", "贝斯", "鼓", "键盘", "弦乐", 
    "制作团队", "打击乐", "采样", "音效", "人声", "合成器", "录音师", "混音师", "编曲师",
    "出品", "发行", "企划", "统筹", "后期", "音乐总监"
)

CREDIT_RE = re.compile(
    rf"^({'|'.join(re.escape(k) for k in CREDIT_KEYWORDS)})\s*[:：]\s*.+$"
)

# "纯音乐，请欣赏"类提示关键字
PURE_MUSIC_PHRASES = (
    "纯音乐，请欣赏",
    "纯音乐, 请欣赏",
    "纯音乐 请欣赏",
    "此歌曲为没有填词的纯音乐",
    "instrumental",
)


@dataclass
class ParsedLRC:
    """
    LRC 解析结果：
      - synced: 带时间戳的 LRC 内容（已标准化）
      - plain: 纯文本歌词（不包含时间标签）
      - is_instrumental: 是否检测到"纯音乐"性质
    """
    synced: str
    plain: str
    is_instrumental: bool


def read_text_any(path: Path) -> str:
    """
    尝试多种编码读取文本文件
    """
    for enc in ("utf-8-sig", "utf-8", "gb18030"):
        try:
            return path.read_text(encoding=enc)
        except UnicodeDecodeError:
            continue
    return path.read_text(encoding="utf-8", errors="ignore")


def _contains_cjk(text: str) -> bool:
    """粗略判断文本是否包含中日韩文字"""
    return bool(re.search(r'[\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF]', text))


def parse_lrc_file(path: Path, *, remove_translations: bool = True) -> ParsedLRC:
    """
    增强版 LRC 解析（带容错处理）
    
    Args:
        path: LRC 文件路径
        remove_translations: 是否删除重复时间戳的翻译行（默认 True）
    
    Returns:
        ParsedLRC(synced, plain, is_instrumental)
    """
    # 容错：读取文件失败
    try:
        raw = read_text_any(path)
    except Exception as e:
        log_error(f"读取 LRC 文件失败 {path}: {e}")
        return ParsedLRC(synced="", plain="", is_instrumental=False)
    
    # 容错：检查是否有有效时间戳
    if not TIMESTAMP_RE.search(raw):
        log_warn(f"LRC 文件无有效时间戳: {path}")
        return ParsedLRC(synced="", plain="", is_instrumental=False)
    
    raw = raw.replace("\r\n", "\n").replace("\r", "\n")
    
    synced_lines: List[str] = []
    plain_lines: List[str] = []
    is_instrumental = False
    
    started = False
    prev_timestamp: Optional[str] = None
    
    for line in raw.splitlines():
        s = line.strip()
        
        # 阶段 1: 删除歌词头
        if not started:
            if TIMESTAMP_RE.match(s):
                started = True
            else:
                continue
        
        # 阶段 2: 处理已开始的歌词内容
        
        # 空行
        if not s:
            synced_lines.append("")
            plain_lines.append("")
            prev_timestamp = None
            continue
        
        # LRC 头部标签
        if HEADER_TAG_RE.match(s):
            synced_lines.append(line)
            prev_timestamp = None
            continue
        
        # 提取时间戳和歌词文本
        timestamp_match = EXTENDED_TIMESTAMP_RE.match(s)
        
        if timestamp_match:
            current_timestamp = timestamp_match.group(0)
            text_no_tag = s[len(current_timestamp):].strip()
            
            # 检测"纯音乐，请欣赏"
            if text_no_tag and any(p in text_no_tag for p in PURE_MUSIC_PHRASES):
                is_instrumental = True
                prev_timestamp = None
                continue
            
            # 检测 credit 信息
            if text_no_tag and CREDIT_RE.match(text_no_tag):
                prev_timestamp = None
                continue
            
            # 检测中文翻译行
            if remove_translations and prev_timestamp == current_timestamp:
                if _contains_cjk(text_no_tag):
                    continue
            
            # 正常歌词行
            synced_lines.append(line)
            plain_lines.append(text_no_tag)
            prev_timestamp = current_timestamp
        
        else:
            synced_lines.append(line)
            if s:
                plain_lines.append(s)
            prev_timestamp = None
    
    # 清理 plain 顶部/尾部的空行
    while plain_lines and not plain_lines[0]:
        plain_lines.pop(0)
    while plain_lines and not plain_lines[-1]:
        plain_lines.pop()
    
    synced = "\n".join(synced_lines)
    plain = "\n".join(plain_lines)
    
    return ParsedLRC(
        synced=synced,
        plain=plain,
        is_instrumental=is_instrumental,
    )


def write_lrc_file(path: Path, content: str) -> bool:
    """
    将标准化后的 LRC 内容写回文件（使用 UTF-8 编码）
    """
    try:
        path.write_text(content, encoding='utf-8')
        return True
    except Exception as e:
        log_error(f"写入 LRC 文件失败 {path}: {e}")
        return False


def cleanse_lrc_file(path: Path) -> bool:
    """
    标准化 LRC 文件（in-place）
    
    等价于：
        parsed = parse_lrc_file(path)
        write_lrc_file(path, parsed.synced)
    
    Args:
        path: LRC 文件路径
    
    Returns:
        是否成功标准化
    """
    try:
        parsed = parse_lrc_file(path)
        return write_lrc_file(path, parsed.synced)
    except Exception as e:
        log_error(f"标准化 LRC 文件失败 {path}: {e}")
        return False
./model/track.py


===== FILE: ./model/track.py =====

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Optional

from mutagen import File as MutaFile
from mutagen.id3 import ID3NoHeaderError

from ..logging_utils import log_warn, log_error


@dataclass
class TrackMeta:
    """
    表示一首歌曲的元数据（从 MP3 文件读取）
    """

    path: Path
    track: str
    artist: str
    album: str
    duration: int  # 秒

    def __str__(self) -> str:
        return f"{self.artist} - {self.track} ({self.album}, {self.duration}s)"

    @staticmethod
    def _get_tag(tags, key: str) -> Optional[str]:
        """从 Mutagen 的 tag 对象中安全获取 text 字段"""
        field = tags.get(key)
        return field.text[0] if field and getattr(field, "text", None) else None

    @classmethod
    def from_mp3(cls, mp3_path: Path) -> Optional["TrackMeta"]:
        """
        从 MP3 文件读取元数据。
        出现异常/标签不完整时返回 None。
        """
        try:
            audio = MutaFile(mp3_path)
            if audio is None or audio.tags is None:
                log_warn(f"无法读取标签：{mp3_path.name}")
                return None
        except ID3NoHeaderError:
            log_warn(f"无 ID3 标签：{mp3_path.name}")
            return None
        except Exception as e:
            log_error(f"读取标签异常 {mp3_path.name}: {e}")
            return None

        tags = audio.tags

        track = cls._get_tag(tags, "TIT2")
        artist = cls._get_tag(tags, "TPE1")
        album = cls._get_tag(tags, "TALB")

        if not track or not artist or not album:
            log_warn(f"标签不完整：{mp3_path.name}")
            return None

        duration = int(round(getattr(audio.info, "length", 0)))
        if duration <= 0:
            log_warn(f"时长无效：{mp3_path.name}")
            return None

        return cls(
            path=mp3_path,
            track=track,
            artist=artist,
            album=album,
            duration=duration,
        )
./model/lyrics.py


===== FILE: ./model/lyrics.py =====

from __future__ import annotations

from dataclasses import dataclass
from typing import Optional, Dict, Any


@dataclass
class LyricsRecord:
    """
    表示从 LRCLIB API 返回的歌词记录
    """

    plain: str
    synced: str
    instrumental: bool

    @classmethod
    def from_api(cls, data: Dict[str, Any]) -> "LyricsRecord":
        """
        从 API 返回的 JSON 构造 LyricsRecord
        
        API 返回格式：
        {
            "plainLyrics": "...",
            "syncedLyrics": "...",
            "instrumental": false,
            ...
        }
        """
        plain = data.get("plainLyrics") or ""
        synced = data.get("syncedLyrics") or ""
        instrumental = bool(data.get("instrumental", False))
        
        # 如果两个歌词字段都为空且没有明确标记 instrumental，
        # 也视为纯音乐
        if not plain.strip() and not synced.strip() and not instrumental:
            instrumental = True
        
        return cls(
            plain=plain,
            synced=synced,
            instrumental=instrumental,
        )

    def is_empty(self) -> bool:
        """判断歌词是否为空"""
        return not self.plain.strip() and not self.synced.strip()
./model/__init__.py


===== FILE: ./model/__init__.py =====

"""
数据模型模块
"""

from .track import TrackMeta
from .lyrics import LyricsRecord

__all__ = [
    "TrackMeta",
    "LyricsRecord",
]
./api/pow.py


===== FILE: ./api/pow.py =====

from __future__ import annotations

import hashlib

from ..exceptions import PoWError
from ..logging_utils import log_info


def solve_pow(prefix: str, target_hex: str) -> str:
    """
    按官方说明 + LRCGET 的实现习惯：

    - target 是 16 进制字符串，表示一个 256 位整数阈值
    - 在 nonce 为 0,1,2,... 中寻找第一个满足：
        sha256(prefix + str(nonce)) <= target
    - 返回 nonce 的十进制字符串
    """
    if not prefix or not target_hex:
        raise PoWError(f"无效 PoW 参数：prefix={prefix!r}, target={target_hex!r}")

    target = int(target_hex, 16)

    nonce = 0
    while True:
        token_bytes = (prefix + str(nonce)).encode("utf-8")
        digest = hashlib.sha256(token_bytes).hexdigest()
        if int(digest, 16) <= target:
            log_info(f"Found nonce: {nonce}")
            return str(nonce)
        nonce += 1
./api/client.py


===== FILE: ./api/client.py =====

from __future__ import annotations

from typing import Optional

from ..config import AppConfig
from ..model import TrackMeta, LyricsRecord
from ..logging_utils import log_info, log_warn
from .http import http_request_json
from .publish import (
    upload_lyrics as _upload_lyrics_impl,
    upload_instrumental as _upload_instrumental_impl,
)


def _check_duration(meta: TrackMeta, record: dict, label: str) -> None:
    """
    打印 LRCLIB 返回的 duration 与本地 duration 的差值提示。
    """
    rec_dur = record.get("duration")
    if rec_dur is None:
        return

    try:
        rec_dur_int = int(round(float(rec_dur)))
    except Exception:
        return

    diff = abs(rec_dur_int - meta.duration)
    if diff <= 2:
        log_info(
            f"{label} 时长检查：LRCLIB={rec_dur_int}s, "
            f"本地={meta.duration}s, 差值={diff}s（<=2s，符合匹配条件）"
        )
    else:
        log_warn(
            f"{label} 时长检查：LRCLIB={rec_dur_int}s, "
            f"本地={meta.duration}s, 差值={diff}s（>2s，可能不是同一首）"
        )


class ApiClient:
    """
    高层 API 封装：

    - get_cached()  : 调用 /api/get-cached，只查内部数据库
    - get_external(): 调用 /api/get，会触发 LRCLIB 外部抓取
    - upload_lyrics(): 语义化包装 /api/publish（带歌词）
    - upload_instrumental(): 语义化包装 /api/publish（纯音乐）
    """

    def __init__(self, config: AppConfig) -> None:
        self.config = config

    def _api_get_common(
        self,
        meta: TrackMeta,
        endpoint: str,
        label: str,
    ) -> Optional[LyricsRecord]:
        """
        通用的 /api/get* 调用逻辑
        """
        params = {
            "track_name": meta.track,
            "artist_name": meta.artist,
            "album_name": meta.album,
            "duration": meta.duration,
        }

        url = f"{self.config.lrclib_base}/{endpoint}"

        data = http_request_json(
            self.config,
            method="GET",
            url=url,
            label=label,
            params=params,
        )
        if not data:
            return None

        _check_duration(meta, data, label)
        return LyricsRecord.from_api(data)

    def get_cached(self, meta: TrackMeta) -> Optional[LyricsRecord]:
        """
        调用 /api/get-cached：只查 LRCLIB 内部数据库
        """
        return self._api_get_common(meta, "get-cached", "内部数据库 (/api/get-cached)")

    def get_external(self, meta: TrackMeta) -> Optional[LyricsRecord]:
        """
        调用 /api/get：会触发 LRCLIB 对外部来源的抓取
        """
        return self._api_get_common(meta, "get", "外部抓取 (/api/get)")

    def upload_lyrics(self, meta: TrackMeta, plain: str, synced: str) -> bool:
        """高层包装：上传带 plain+synced 的歌词"""
        return _upload_lyrics_impl(self.config, meta, plain, synced)

    def upload_instrumental(self, meta: TrackMeta) -> bool:
        """高层包装：以"纯音乐"方式上传"""
        return _upload_instrumental_impl(self.config, meta)
./api/__init__.py


===== FILE: ./api/__init__.py =====

"""
API 模块：与 LRCLIB 交互
"""

from .client import ApiClient
from .publish import upload_lyrics, upload_instrumental

__all__ = [
    "ApiClient",
    "upload_lyrics",
    "upload_instrumental",
]
./api/http.py


===== FILE: ./api/http.py =====

from __future__ import annotations

import random
import time
from typing import Optional, Dict, Any

import requests
from requests import RequestException

from ..config import AppConfig
from ..logging_utils import log_info, log_warn, log_error


def _calculate_backoff(attempt: int, base: float = 1.0, max_delay: float = 30.0) -> float:
    """
    计算指数退避延迟时间（带抖动）
    
    Args:
        attempt: 当前重试次数（从 1 开始）
        base: 基础延迟时间
        max_delay: 最大延迟时间
    
    Returns:
        延迟秒数
    """
    delay = min(base * (2 ** (attempt - 1)) + random.uniform(0, 1), max_delay)
    return delay


def http_request_json(
    config: AppConfig,
    method: str,
    url: str,
    label: str,
    *,
    params: Optional[Dict[str, Any]] = None,
    json_data: Optional[Dict[str, Any]] = None,
    timeout: int = 20,
    max_retries: Optional[int] = None,
    treat_404_as_none: bool = True,
) -> Optional[Dict[str, Any]]:
    """
    封装 GET / POST JSON 请求的通用函数：

    - 遵循 config.max_http_retries 进行重试
    - 对网络异常 / 5xx 做自动重试（使用指数退避）
    - 404 可选视为 None
    - 其余 4xx 报错后不重试
    """
    retries = max_retries if max_retries is not None else config.max_http_retries

    for attempt in range(1, retries + 1):
        try:
            resp = requests.request(
                method=method,
                url=url,
                params=params,
                json=json_data,
                timeout=timeout,
                headers={"User-Agent": config.user_agent},
            )
        except RequestException as e:
            backoff = _calculate_backoff(attempt)
            log_warn(
                f"{label} 调用失败（第 {attempt}/{retries} 次），"
                f"等待 {backoff:.1f}s 后重试: {e}"
            )
            if attempt == retries:
                return None
            time.sleep(backoff)
            continue

        # 特殊处理 404
        if resp.status_code == 404 and treat_404_as_none:
            return None

        if 200 <= resp.status_code < 300:
            try:
                return resp.json()
            except ValueError as e:
                log_warn(
                    f"{label} 解析 JSON 失败: {e} "
                    f"(status={resp.status_code}, body={resp.text[:200]!r})"
                )
                return None

        # 4xx 默认认为是参数/认证问题，不重试
        if 400 <= resp.status_code < 500:
            log_warn(
                f"{label} 请求失败：HTTP {resp.status_code}, body={resp.text[:200]!r}"
            )
            return None

        # 5xx → 重试
        backoff = _calculate_backoff(attempt)
        log_warn(
            f"{label} 请求失败：HTTP {resp.status_code}, "
            f"body={resp.text[:200]!r}（第 {attempt}/{retries} 次），"
            f"等待 {backoff:.1f}s 后重试"
        )
        if attempt == retries:
            return None
        time.sleep(backoff)

    return None
./api/publish.py


===== FILE: ./api/publish.py =====

from __future__ import annotations

import random
import time
from typing import Optional, Dict, Any

import requests
from requests import RequestException

from ..config import AppConfig
from ..model import TrackMeta
from ..logging_utils import log_info, log_warn, log_error
from .http import http_request_json
from .pow import solve_pow


# -------------------- Publish Token / PoW --------------------


def request_publish_token(config: AppConfig) -> Optional[str]:
    """
    调用 /api/request-challenge，执行 PoW，返回完整的
      X-Publish-Token = "{prefix}:{nonce}"
    """
    url = f"{config.lrclib_base}/request-challenge"
    data = http_request_json(
        config,
        "POST",
        url,
        "请求发布令牌 (/api/request-challenge)",
        treat_404_as_none=False,
    )
    if not data:
        return None

    prefix = data.get("prefix")
    target = data.get("target")
    if not prefix or not target:
        log_error(f"请求发布令牌返回异常数据：{data}")
        return None

    try:
        nonce = solve_pow(prefix, target)
    except Exception as e:
        log_error(f"PoW 求解失败：{e}")
        return None

    return f"{prefix}:{nonce}"


# -------------------- Publish with retry --------------------


def _calculate_backoff(attempt: int, base: float = 1.0, max_delay: float = 30.0) -> float:
    """计算指数退避延迟时间（带抖动）"""
    return min(base * (2 ** (attempt - 1)) + random.uniform(0, 1), max_delay)


def publish_with_retry(
    config: AppConfig,
    meta: TrackMeta,
    payload: Dict[str, Any],
    label: str,
) -> bool:
    """
    对 /api/publish 做一层自动重试：
      - 每次重试都会重新请求 challenge + 重新 PoW
      - 成功（201）即返回 True
      - 4xx 认为是参数或 Token 问题，不重试
    """
    url = f"{config.lrclib_base}/publish"
    retries = config.max_http_retries

    for attempt in range(1, retries + 1):
        token = request_publish_token(config)
        if not token:
            backoff = _calculate_backoff(attempt)
            log_warn(
                f"{label}：获取发布令牌失败（第 {attempt}/{retries} 次），"
                f"等待 {backoff:.1f}s 后重试"
            )
            if attempt == retries:
                return False
            time.sleep(backoff)
            continue

        headers = {
            "X-Publish-Token": token,
            "Content-Type": "application/json",
            "User-Agent": config.user_agent,
        }

        try:
            resp = requests.post(url, json=payload, headers=headers, timeout=30)
        except RequestException as e:
            backoff = _calculate_backoff(attempt)
            log_warn(
                f"{label} (/api/publish) 调用失败（第 {attempt}/{retries} 次），"
                f"等待 {backoff:.1f}s 后重试: {e}"
            )
            if attempt == retries:
                return False
            time.sleep(backoff)
            continue

        if resp.status_code == 201:
            return True

        # 4xx: 参数/Token 错误，不再重试
        if 400 <= resp.status_code < 500:
            log_error(
                f"{label} 失败：HTTP {resp.status_code}, body={resp.text[:200]!r} "
                "（4xx 错误，一般是参数或 Token 问题，不再重试）"
            )
            return False

        # 5xx: 重试
        backoff = _calculate_backoff(attempt)
        log_warn(
            f"{label} 失败：HTTP {resp.status_code}, body={resp.text[:200]!r} "
            f"（第 {attempt}/{retries} 次），等待 {backoff:.1f}s 后重试"
        )
        if attempt == retries:
            return False
        time.sleep(backoff)

    return False


# -------------------- Payload 构造 --------------------


def build_payload_for_publish(
    meta: TrackMeta,
    plain: Optional[str],
    synced: Optional[str],
    *,
    force_instrumental: bool = False,
) -> Dict[str, Any]:
    """
    构造 /api/publish 的 JSON
    """
    base: Dict[str, Any] = {
        "trackName": meta.track,
        "artistName": meta.artist,
        "albumName": meta.album,
        "duration": meta.duration,
    }

    if force_instrumental:
        return base

    p = (plain or "").strip()
    s = (synced or "").strip()

    if not p and not s:
        return base

    base["plainLyrics"] = p
    base["syncedLyrics"] = s
    return base


# -------------------- 高阶上传函数 --------------------


def upload_lyrics(
    config: AppConfig,
    meta: TrackMeta,
    plain: str,
    synced: str,
) -> bool:
    payload = build_payload_for_publish(meta, plain, synced, force_instrumental=False)
    return publish_with_retry(config, meta, payload, "上传歌词")


def upload_instrumental(config: AppConfig, meta: TrackMeta) -> bool:
    """按"纯音乐曲目"上传"""
    payload = build_payload_for_publish(meta, plain=None, synced=None, force_instrumental=True)
    return publish_with_retry(config, meta, payload, "上传纯音乐标记")
./exceptions.py


===== FILE: ./exceptions.py =====

from __future__ import annotations


class PylrclibupError(Exception):
    """包内自定义异常的基类。"""


class NetworkError(PylrclibupError):
    """表示网络相关错误（如多次重试仍失败）。"""


class PublishTokenError(PylrclibupError):
    """获取或验证发布 Token 失败。"""


class PoWError(PylrclibupError):
    """PoW 求解失败或 challenge 数据异常。"""


class ApiResponseError(PylrclibupError):
    """LRCLIB API 返回了非预期的响应。"""


class LrcNotFoundError(PylrclibupError):
    """为某首歌找不到对应的 LRC 文件。"""

class ApiError(PylrclibupError):
    """API 调用相关异常"""
    pass

class ConfigError(PylrclibupError):
    """配置相关异常"""
    pass

class LrcParseError(PylrclibupError):
    """LRC 解析相关异常"""
    pass

class InstrumentalDetected(PylrclibupError):
    """
    标记解析过程中检测到纯音乐。
    在某些高级用法下，可能希望通过异常来中断普通歌词流程。
    """
./fs/mover.py


===== FILE: ./fs/mover.py =====

from __future__ import annotations

from pathlib import Path
from typing import Optional

from ..logging_utils import log_warn


def move_with_dedup(
    src: Path,
    dst_dir: Path,
    *,
    new_name: Optional[str] = None
) -> Optional[Path]:
    """
    将 src 移动到 dst_dir，若同名文件已存在，则自动添加 _dup 后缀。
    
    特殊处理：
      - 如果源文件已在目标目录且无需重命名 → 直接返回源路径
      - 如果目标文件存在且与源文件不同 → 添加 _dup 后缀

    返回最终路径；若失败返回 None。
    """
    try:
        dst_dir.mkdir(parents=True, exist_ok=True)
        
        # 确定目标文件名
        if new_name:
            target = dst_dir / f"{new_name}{src.suffix}"
        else:
            target = dst_dir / src.name
        
        # 检查是否为原地移动
        src_resolved = src.resolve()
        target_resolved = target.resolve()
        
        if src_resolved == target_resolved:
            return src
        
        # 处理重名情况
        if target.exists():
            stem = target.stem
            suffix = target.suffix
            dedup = 1
            while True:
                candidate = dst_dir / f"{stem}_dup{dedup}{suffix}"
                if not candidate.exists():
                    target = candidate
                    break
                dedup += 1
        
        # 执行移动/重命名
        src.rename(target)
        return target

    except Exception as e:
        log_warn(f"移动文件失败：{src} → {dst_dir}：{e}")
        return None
./fs/__init__.py


===== FILE: ./fs/__init__.py =====

"""
文件系统操作模块
"""

from .mover import move_with_dedup
from .cleaner import cleanup_empty_dirs

__all__ = [
    "move_with_dedup",
    "cleanup_empty_dirs",
]
./fs/cleaner.py


===== FILE: ./fs/cleaner.py =====

from __future__ import annotations

from pathlib import Path

from ..logging_utils import log_info, log_warn


def cleanup_empty_dirs(root: Path) -> None:
    """
    递归删除 root 下的空目录（不删除 root 本身）
    
    采用自底向上的方式，确保子目录先于父目录被检查
    """
    if not root.exists() or not root.is_dir():
        return
    
    # 收集所有子目录（自底向上排序）
    all_dirs = sorted(root.rglob("*"), key=lambda p: len(p.parts), reverse=True)
    
    for d in all_dirs:
        if not d.is_dir():
            continue
        
        try:
            # 检查目录是否为空
            if not any(d.iterdir()):
                d.rmdir()
                log_info(f"已删除空目录：{d}")
        except PermissionError:
            log_warn(f"无权限删除目录：{d}")
        except OSError as e:
            log_warn(f"删除目录失败 {d}: {e}")
./logging_utils.py


===== FILE: ./logging_utils.py =====

"""
pylrclibup 统一日志模块

提供全局统一的日志输出接口，替代各模块分散定义的 _log_* 函数。
"""

from __future__ import annotations

import logging
import sys
from typing import Optional


# 全局 logger 实例
_logger: Optional[logging.Logger] = None


def get_logger() -> logging.Logger:
    """获取或创建全局 logger 实例"""
    global _logger
    if _logger is None:
        _logger = _setup_logger()
    return _logger


def _setup_logger(
    name: str = "pylrclibup",
    level: int = logging.INFO,
) -> logging.Logger:
    """
    初始化并配置 logger
    
    Args:
        name: logger 名称
        level: 日志级别
    
    Returns:
        配置好的 Logger 实例
    """
    logger = logging.getLogger(name)
    
    # 避免重复添加 handler
    if logger.handlers:
        return logger
    
    logger.setLevel(level)
    
    # stdout handler（INFO 及以下）
    stdout_handler = logging.StreamHandler(sys.stdout)
    stdout_handler.setLevel(logging.DEBUG)
    stdout_handler.addFilter(lambda record: record.levelno < logging.ERROR)
    stdout_handler.setFormatter(logging.Formatter("[%(levelname)s] %(message)s"))
    
    # stderr handler（ERROR 及以上）
    stderr_handler = logging.StreamHandler(sys.stderr)
    stderr_handler.setLevel(logging.ERROR)
    stderr_handler.setFormatter(logging.Formatter("[%(levelname)s] %(message)s"))
    
    logger.addHandler(stdout_handler)
    logger.addHandler(stderr_handler)
    
    # 阻止向上传播
    logger.propagate = False
    
    return logger


def set_log_level(level: int) -> None:
    """动态设置日志级别"""
    get_logger().setLevel(level)


# -------------------- 便捷函数（保持向后兼容） --------------------


def log_info(msg: str) -> None:
    """输出 INFO 级别日志"""
    get_logger().info(msg)


def log_warn(msg: str) -> None:
    """输出 WARNING 级别日志"""
    get_logger().warning(msg)


def log_error(msg: str) -> None:
    """输出 ERROR 级别日志"""
    get_logger().error(msg)


def log_debug(msg: str) -> None:
    """输出 DEBUG 级别日志"""
    get_logger().debug(msg)
