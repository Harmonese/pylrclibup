===== FILE: pylrclibup/config.py =====
from __future__ import annotations

import os
from dataclasses import dataclass
from pathlib import Path
from typing import Optional


# -------------------- 常量（全局配置） --------------------

# LRCLIB API 根地址
LRCLIB_BASE = "https://lrclib.net/api"

# 预览歌词时显示的最大行数
PREVIEW_LINES_DEFAULT = 10

# HTTP 调用最大自动重试次数
MAX_HTTP_RETRIES_DEFAULT = 5

# 默认 User-Agent（可以在 CLI 里加个选项覆盖）
DEFAULT_USER_AGENT = "pylrclibup/0.1 (https://github.com/yourname/pylrclibup)"


# -------------------- AppConfig --------------------


@dataclass
class AppConfig:
    """
    全局配置对象：

    - tracks_dir: MP3 输入目录
    - lrc_dir: LRC 输入目录
    - done_tracks_dir: MP3 输出目录
    - done_lrc_dir: LRC 输出目录
    - preview_lines: 预览歌词时显示的最大行数
    - max_http_retries: HTTP 自动重试次数
    - user_agent: 发送给 LRCLIB 的 User-Agent
    """

    tracks_dir: Path
    lrc_dir: Path
    done_tracks_dir: Path
    done_lrc_dir: Path

    preview_lines: int = PREVIEW_LINES_DEFAULT
    max_http_retries: int = MAX_HTTP_RETRIES_DEFAULT
    user_agent: str = DEFAULT_USER_AGENT

    lrclib_base: str = LRCLIB_BASE

    @classmethod
    def from_env_and_defaults(
        cls,
        *,
        tracks_dir: Optional[str | Path] = None,
        lrc_dir: Optional[str | Path] = None,
        done_tracks_dir: Optional[str | Path] = None,
        done_lrc_dir: Optional[str | Path] = None,
        preview_lines: Optional[int] = None,
        max_http_retries: Optional[int] = None,
        user_agent: Optional[str] = None,
    ) -> "AppConfig":
        """
        统一入口：综合考虑
          1. 显式传入（通常来自 CLI 参数）
          2. 环境变量
          3. 默认值

        优先级：参数 > 环境变量 > 默认
        """

        # ---- 路径类配置 ----
        # 默认基于当前工作目录（而不是包所在目录）
        cwd = Path.cwd()

        # 环境变量
        env_tracks = os.getenv("PYLRCLIBUP_TRACKS_DIR")
        env_lrc = os.getenv("PYLRCLIBUP_LRC_DIR")
        env_done_tracks = os.getenv("PYLRCLIBUP_DONE_TRACKS_DIR")
        env_done_lrc = os.getenv("PYLRCLIBUP_DONE_LRC_DIR")

        tracks = Path(
            tracks_dir
            or env_tracks
            or cwd / "tracks"
        )
        lrc = Path(
            lrc_dir
            or env_lrc
            or cwd / "lrc-files"
        )
        done_tracks = Path(
            done_tracks_dir
            or env_done_tracks
            or cwd / "done-tracks"
        )
        done_lrc = Path(
            done_lrc_dir
            or env_done_lrc
            or cwd / "done-lrc-files"
        )

        # ---- 数值配置 ----
        if preview_lines is None:
            # 若未显式指定，允许通过环境变量覆盖
            env_preview = os.getenv("PYLRCLIBUP_PREVIEW_LINES")
            if env_preview and env_preview.isdigit():
                preview_lines_val = int(env_preview)
            else:
                preview_lines_val = PREVIEW_LINES_DEFAULT
        else:
            preview_lines_val = preview_lines

        if max_http_retries is None:
            env_retries = os.getenv("PYLRCLIBUP_MAX_HTTP_RETRIES")
            if env_retries and env_retries.isdigit():
                max_http_retries_val = int(env_retries)
            else:
                max_http_retries_val = MAX_HTTP_RETRIES_DEFAULT
        else:
            max_http_retries_val = max_http_retries

        # ---- User-Agent ----
        ua = user_agent or os.getenv("PYLRCLIBUP_USER_AGENT") or DEFAULT_USER_AGENT

        return cls(
            tracks_dir=tracks,
            lrc_dir=lrc,
            done_tracks_dir=done_tracks,
            done_lrc_dir=done_lrc,
            preview_lines=preview_lines_val,
            max_http_retries=max_http_retries_val,
            user_agent=ua,
        )

===== FILE: pylrclibup/processor/__init__.py =====
from .core import process_track, process_all

__all__ = ["process_track", "process_all"]

===== FILE: pylrclibup/processor/core.py =====
from __future__ import annotations

import sys
from pathlib import Path
from typing import Iterable, List, Optional

from ..config import AppConfig
from ..model import TrackMeta, LyricsRecord
from ..lrc import find_lrc_for_track, parse_lrc_file, ParsedLRC
from ..api import ApiClient, upload_lyrics, upload_instrumental
from ..fs import move_with_dedup, cleanup_empty_dirs


# -------------------- 日志 + 预览 --------------------


def _log_info(msg: str) -> None:
    print(f"[INFO] {msg}")


def _log_warn(msg: str) -> None:
    print(f"[WARN] {msg}")


def _log_error(msg: str) -> None:
    print(f"[ERROR] {msg}", file=sys.stderr)


def _preview(label: str, text: str, max_lines: int) -> None:
    print(f"--- {label} ---")
    if not text:
        print("[空]")
        print("-" * 40)
        return
    lines = text.splitlines()
    for ln in lines[:max_lines]:
        print(ln)
    if len(lines) > max_lines:
        print(f"... 共 {len(lines)} 行")
    print("-" * 40)


# -------------------- 文件移动 & 清理 --------------------


def _move_after_done(
    config: AppConfig,
    meta: TrackMeta,
    lrc_path: Optional[Path],
) -> None:
    """
    在以下场景调用：
      - /api/get-cached 已有歌词
      - 上传成功（外部歌词 / 本地 LRC / 纯音乐）

    规则：
      - MP3 一定移动到 done_tracks_dir
      - LRC 如存在则移动到 done_lrc_dir
      - 移动后清理 tracks_dir 与 lrc_dir 下的空目录
    """
    if lrc_path and lrc_path.exists():
        new_lrc = move_with_dedup(lrc_path, config.done_lrc_dir)
        if new_lrc:
            _log_info(f"LRC 已移动到：{new_lrc}")

    if meta.path.exists():
        new_mp3 = move_with_dedup(meta.path, config.done_tracks_dir)
        if new_mp3:
            _log_info(f"MP3 已移动到：{new_mp3}")

    cleanup_empty_dirs(config.tracks_dir)
    cleanup_empty_dirs(config.lrc_dir)


# -------------------- 单曲处理逻辑 --------------------


def process_track(
    config: AppConfig,
    api_client: ApiClient,
    meta: TrackMeta,
    *,
    auto_yes: bool = False,
    dry_run: bool = False,
) -> None:
    """
    按你原来脚本的逻辑，处理一首歌：
      1. /api/get-cached 查内部数据库
      2. /api/get 查外部歌词（可选用）
      3. 本地 LRC（递归匹配）
      4. LRC 解析（删除 credit / 识别纯音乐）
      5. 上传（歌词 / 纯音乐）
      6. 移动文件 & 清理空目录
    """
    _log_info(f"处理：{meta}")

    # 1. 先查内部数据库（不触发外部抓取）
    cached: Optional[LyricsRecord] = api_client.get_cached(meta)
    if cached:
        _log_info("内部数据库已存在歌词 → 自动移动 MP3+LRC 并跳过上传（不再重复提交）")
        _preview("已有 plainLyrics", cached.plain, config.preview_lines)
        _preview("已有 syncedLyrics", cached.synced, config.preview_lines)

        lrc_path = find_lrc_for_track(meta, config, interactive=True)
        _move_after_done(config, meta, lrc_path)
        return

    # 2. 再查外部抓取（仅供参考，可选是否直接使用）
    external: Optional[LyricsRecord] = api_client.get_external(meta)
    if external:
        plain_ext = external.plain
        synced_ext = external.synced
        instrumental_ext = external.instrumental

        _log_info("外部抓取到歌词（仅供参考，可选择是否直接使用外部版本上传）：")
        _preview("外部 plainLyrics", plain_ext, config.preview_lines)
        _preview("外部 syncedLyrics", synced_ext, config.preview_lines)

        if instrumental_ext:
            _log_info("外部记录中该曲被标记为 instrumental（或两种歌词字段均为空）。")

        if dry_run:
            _log_info("[dry-run] 模式下，仅展示外部结果，不上传，也不继续本地处理。")
            return

        use_ext = False
        if auto_yes:
            # 自动模式优先使用外部结果
            use_ext = True
        else:
            choice = input("是否直接使用外部版本上传？[y/N]: ").strip().lower()
            use_ext = choice in ("y", "yes")

        if use_ext:
            if instrumental_ext:
                _log_info("将使用“纯音乐”方式上传（不包含任何歌词内容，只标记为 instrumental）。")
                ok = upload_instrumental(config, meta)
            else:
                _log_info("将直接使用外部 plain+synced 歌词上传。")
                ok = upload_lyrics(config, meta, plain_ext, synced_ext)

            if ok:
                _log_info("外部歌词上传完成 ✓")
                lrc_path = find_lrc_for_track(meta, config, interactive=True)
                _move_after_done(config, meta, lrc_path)
            else:
                _log_error("外部歌词上传失败 ×")
            return
        else:
            _log_info("用户选择不直接使用外部歌词 → 继续尝试本地 LRC。")

    # 3. 查找本地 LRC 文件
    lrc_path = find_lrc_for_track(meta, config, interactive=True)
    if not lrc_path:
        _log_warn(f"⚠ 未找到本地 LRC 文件：{meta.track}")
        if dry_run:
            _log_info("[dry-run] 模式下，未找到 LRC，仅提示，不上传，不标记纯音乐。")
            return

        while True:
            choice = input(
                "未找到本地 LRC，选择 "
                "[s] 跳过该歌曲 / "
                "[i] 上传空歌词标记为纯音乐 / "
                "[q] 退出程序: "
            ).strip().lower()

            if choice == "s":
                _log_info("跳过该歌曲，不上传、不移动。")
                return
            elif choice == "i":
                _log_info("将上传空歌词（标记为纯音乐）。")
                ok = upload_instrumental(config, meta)
                if ok:
                    _log_info("纯音乐标记上传完成 ✓")
                    _move_after_done(config, meta, lrc_path=None)
                else:
                    _log_error("纯音乐标记上传失败 ×")
                return
            elif choice == "q":
                _log_info("用户选择退出程序。")
                sys.exit(1)
            else:
                print("无效输入，请重新选择。")

    # 4. 解析本地 LRC
    parsed: ParsedLRC = parse_lrc_file(lrc_path)

    if parsed.is_instrumental:
        _log_info("LRC 中检测到“纯音乐，请欣赏”等字样，将按纯音乐处理（不上传歌词内容）。")

    _preview("本地 plainLyrics（整理后，将上传）", parsed.plain, config.preview_lines)
    _preview("本地 syncedLyrics（整理后，将上传）", parsed.synced, config.preview_lines)

    if dry_run:
        _log_info("[dry-run] 模式，仅预览 LRC，不上传。")
        return

    # 判断是否按纯音乐上传
    treat_as_instrumental = parsed.is_instrumental or (
        not parsed.plain.strip() and not parsed.synced.strip()
    )

    if treat_as_instrumental:
        _log_info("根据解析结果：将按纯音乐曲目上传。")
        if not auto_yes:
            choice = input("确认以纯音乐方式上传？[y/N]: ").strip().lower()
            if choice not in ("y", "yes"):
                _log_info("用户取消上传。")
                return

        ok = upload_instrumental(config, meta)
        if ok:
            _log_info("纯音乐上传完成 ✓")
            _move_after_done(config, meta, lrc_path)
        else:
            _log_error("纯音乐上传失败 ×")
        return

    # 非纯音乐 → 正常上传 plain+synced
    if not auto_yes:
        choice = input("确认上传本地歌词？[y/N]: ").strip().lower()
        if choice not in ("y", "yes"):
            _log_info("用户取消上传。")
            return

    ok = upload_lyrics(config, meta, parsed.plain, parsed.synced)
    if ok:
        _log_info("上传完成 ✓")
        _move_after_done(config, meta, lrc_path)
    else:
        _log_error("上传失败 ×")


# -------------------- 批量处理 --------------------


def process_all(
    config: AppConfig,
    *,
    auto_yes: bool = False,
    dry_run: bool = False,
    single: Optional[str] = None,
) -> None:
    """
    入口函数，等价于你之前脚本中的 main() 行为：

      - 如果 single 不为空 → 只处理指定文件
      - 否则递归扫描 tracks_dir 下所有 .mp3

    CLI 层只需要调用这一层。
    """
    api_client = ApiClient(config)

    metas: List[TrackMeta] = []

    if single:
        mp3 = config.tracks_dir / single
        if not mp3.is_file():
            _log_error(f"文件不存在：{mp3}")
            return
        tm = TrackMeta.from_mp3(mp3)
        if tm:
            metas.append(tm)
    else:
        for p in sorted(config.tracks_dir.rglob("*.mp3")):
            tm = TrackMeta.from_mp3(p)
            if tm:
                metas.append(tm)

    for meta in metas:
        process_track(
            config,
            api_client,
            meta,
            auto_yes=auto_yes,
            dry_run=dry_run,
        )
        print()

    _log_info("全部完成。")

===== FILE: pylrclibup/__init__.py =====
"""
pylrclibup

A tool to upload local LRC lyrics / instrumental markers to LRCLIB.net,
based on track metadata from your music library (e.g. Jellyfin + MusicBrainz Picard).
"""

from .config import AppConfig

__all__ = ["AppConfig"]

__version__ = "0.1.0"

===== FILE: pylrclibup/cli/__init__.py =====
from .main import run_cli

__all__ = ["run_cli"]

===== FILE: pylrclibup/cli/main.py =====
from __future__ import annotations

import argparse
import sys
from pathlib import Path

from ..config import AppConfig
from ..processor import process_all


def run_cli():
    """
    pylrclibup 的命令行入口点。
    """

    parser = argparse.ArgumentParser(
        prog="pylrclibup",
        description="Upload lyrics or instrumental tags to LRCLIB with local files."
    )

    # 与你原脚本一致
    parser.add_argument("--yes", action="store_true",
                        help="不询问确认，默认选择“上传”或“使用外部歌词”")

    parser.add_argument("--dry-run", action="store_true",
                        help="仅预览，不执行任何上传和移动")

    parser.add_argument("--single", type=str,
                        help="只处理 tracks/ 中指定文件，例如 'foo.mp3'")

    # 新增：可自定义路径
    parser.add_argument("--root", default=".",
                        help="根目录（默认当前目录）")
    parser.add_argument("--tracks", default="tracks",
                        help="mp3 输入目录（相对 root）")
    parser.add_argument("--lrc", default="lrc-files",
                        help="lrc 输入目录（相对 root）")
    parser.add_argument("--done-tracks", default="done-tracks",
                        help="mp3 输出目录（相对 root）")
    parser.add_argument("--done-lrc", default="done-lrc-files",
                        help="lrc 输出目录（相对 root）")

    parser.add_argument("--preview-lines", type=int, default=10,
                        help="预览歌词时显示的行数")

    args = parser.parse_args()

    # 构建 AppConfig
    root = Path(args.root).resolve()

    config = AppConfig.from_env_and_defaults(
        tracks_dir=root / args.tracks,
        lrc_dir=root / args.lrc,
        done_tracks_dir=root / args.done_tracks,
        done_lrc_dir=root / args.done_lrc,
        preview_lines=args.preview_lines,
    )

    # 运行主流程
    try:
        process_all(
            config,
            auto_yes=args.yes,
            dry_run=args.dry_run,
            single=args.single,
        )
    except KeyboardInterrupt:
        print("\n[INFO] 用户中断执行（Ctrl+C），已优雅退出。")
        sys.exit(0)

===== FILE: pylrclibup/lrc/matcher.py =====
from __future__ import annotations

from pathlib import Path
from typing import List, Optional, Tuple

from ..config import AppConfig
from ..model import TrackMeta
from .parser import normalize_name


# -------------------- 艺人拆分 & 匹配 --------------------


def split_artists(s: str) -> List[str]:
    """
    将艺人字符串拆分成多个 artist：
      - 支持 "feat." / "featuring" 作为分隔符
      - 支持 "&"、"和"、"/"、";"、"、"、" x " / " X " / "×"
      - 将各种逗号/间隔统一整理
    """
    import re

    s = s.lower()
    # 把 feat/featuring 先转成逗号
    s = re.sub(r"\bfeat\.?\b", ",", s)
    s = re.sub(r"\bfeaturing\b", ",", s)

    # 其他分隔符也统一转成逗号
    for sep in ["&", "和", "/", ";", "、", " x ", " X ", "×"]:
        s = s.replace(sep, ",")

    # 一些特殊逗号/间隔
    for sep in ["，", "､"]:
        s = s.replace(sep, ",")

    artists = [a.strip() for a in s.split(",") if a.strip()]
    # 去重保持顺序
    return list(dict.fromkeys(artists))


def match_artists(mp3_artists: List[str], lrc_artists: List[str]) -> bool:
    """
    艺人匹配策略：
      - 对双方艺人列表 normalize
      - 只要有任意一个艺人名相等 → 认为匹配成功
    """
    mp3_norm = {normalize_name(a) for a in mp3_artists}
    lrc_norm = {normalize_name(a) for a in lrc_artists}
    return not mp3_norm.isdisjoint(lrc_norm)


# -------------------- LRC 文件名解析 & 匹配 --------------------


def parse_lrc_filename(path: Path) -> Tuple[List[str], str]:
    """
    从 LRC 文件名解析出 (artists_list, title_norm)。

    约定格式为：
      "Artist - Title.lrc"

    例如：
      "A & B - Song.lrc"
    会解析为：
      (["a", "b"], "song")

    注意：这里不对 " - " 做任何过滤，这个分隔符是稳定可靠的。
    """
    stem = path.stem
    if " - " not in stem:
        return [], ""
    artist_raw, title_raw = stem.split(" - ", 1)
    artists = split_artists(artist_raw)
    title = normalize_name(title_raw)
    return artists, title


def find_lrc_for_track(
    meta: TrackMeta,
    config: AppConfig,
    *,
    interactive: bool = True,
) -> Optional[Path]:
    """
    在 config.lrc_dir 下递归寻找和某首歌曲匹配的 LRC 文件。

    匹配规则：
      1. 从 MP3 的 meta.track / meta.artist 获取歌名和艺人
      2. 将歌名 normalize 后，与 LRC 文件名中 parse 出的 title_norm 做完全匹配
      3. 艺人名使用 split_artists 拆分，只要任一艺人 match_artists 成功即视为匹配

    行为：
      - 若无匹配 → 返回 None
      - 若匹配到 1 个 → 直接返回
      - 若匹配到多个且 interactive=True → 让用户选择
      - 若匹配到多个且 interactive=False → 返回第一个匹配的路径
    """
    meta_title_norm = normalize_name(meta.track)
    meta_artists = split_artists(meta.artist)

    candidates: List[Path] = []

    for p in config.lrc_dir.rglob("*.lrc"):
        lrc_artists, lrc_title_norm = parse_lrc_filename(p)
        if not lrc_title_norm:
            continue

        # 1) 歌曲名必须完全相等（在 normalize 之后）
        if lrc_title_norm != meta_title_norm:
            continue

        # 2) 艺人名任意一个成功匹配即可
        if match_artists(meta_artists, lrc_artists):
            candidates.append(p)

    if not candidates:
        return None

    if len(candidates) == 1 or not interactive:
        # 单一匹配 or 非交互模式
        return candidates[0]

    # 多个候选 → 交互选择
    print("\n匹配到多个歌词文件，请选择：")
    for idx, c in enumerate(candidates, 1):
        print(f"{idx}) {c}")

    while True:
        choice = input(f"请输入 1-{len(candidates)}: ").strip()
        if choice.isdigit():
            i = int(choice)
            if 1 <= i <= len(candidates):
                return candidates[i - 1]
        print("输入无效，请重新输入。")

===== FILE: pylrclibup/lrc/__init__.py =====
from .parser import (
    normalize_name,
    ParsedLRC,
    parse_lrc_file,
)

from .matcher import (
    split_artists,
    match_artists,
    parse_lrc_filename,
    find_lrc_for_track,
)

__all__ = [
    "normalize_name",
    "ParsedLRC",
    "parse_lrc_file",
    "split_artists",
    "match_artists",
    "parse_lrc_filename",
    "find_lrc_for_track",
]

===== FILE: pylrclibup/lrc/parser.py =====
from __future__ import annotations

import re
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple


# -------------------- 文本规范化 --------------------


def normalize_name(s: str) -> str:
    """
    一般用于艺人名 / 歌曲名等的轻度规范化：
      - 去首尾空白
      - 降为小写
      - 将常见全角标点替换为半角
      - 合并多余空格
    """
    s = s.strip().lower()
    replacements = {
        "（": "(",
        "）": ")",
        "【": "[",
        "】": "]",
        "：": ":",
        "。": ".",
        "，": ",",
        "！": "!",
        "？": "?",
    }
    for k, v in replacements.items():
        s = s.replace(k, v)
    s = re.sub(r"\s+", " ", s)
    return s


# -------------------- LRC 内容解析 --------------------

# 时间标签：
#   [mm:ss.xxx] / [mm:ss.xx] / [mm:ss.x] / [mm:ss.xxx-1] 等
TIMESTAMP_RE = re.compile(
    r"\[\d{2}:\d{2}(?:\.\d{1,3}(?:-\d{1,3})?)?\]"
)

# LRC 头部标签，如 [ar:xxx] / [ti:xxx]
HEADER_TAG_RE = re.compile(r"^\[[a-zA-Z]{2,3}:.+\]$")

# NCM 常见 credit 关键字
CREDIT_KEYWORDS = (
    "作词", "作曲", "编曲",
    "混音", "缩混", "录音",
    "母带", "制作", "监制",
    "和声", "配唱",
)

# 匹配形如“作词 : xxx”/“作曲：xxx”等，注意支持全角/半角冒号
CREDIT_RE = re.compile(
    rf"^({'|'.join(CREDIT_KEYWORDS)})\s*[:：]\s*.+$"
)

# “纯音乐，请欣赏”类提示关键字
PURE_MUSIC_PHRASES = (
    "纯音乐，请欣赏",
    "纯音乐, 请欣赏",
    "纯音乐 请欣赏",
)


@dataclass
class ParsedLRC:
    """
    LRC 解析结果：
      - synced: 仍带时间戳的 LRC 内容（但已经去掉了 credit / 纯音乐提示等）
      - plain: 纯文本歌词（不包含时间标签）
      - is_instrumental: 是否从 LRC 中检测到“纯音乐”性质
    """

    synced: str
    plain: str
    is_instrumental: bool


def read_text_any(path: Path) -> str:
    """
    尝试多种编码读取文本文件：
      - utf-8-sig
      - utf-8
      - gb18030
    """
    for enc in ("utf-8-sig", "utf-8", "gb18030"):
        try:
            return path.read_text(encoding=enc)
        except UnicodeDecodeError:
            continue
    return path.read_text(encoding="utf-8", errors="ignore")


def parse_lrc_file(path: Path) -> ParsedLRC:
    """
    解析 LRC 文件：

    - 保留 LRC 头部标签（[ar:] [ti:] 等）在 synced 中，但不进入 plain
    - 删除 NCM credit 行（作词/作曲/缩混/母带等）
    - 检测包含“纯音乐，请欣赏”类提示 → 标记 is_instrumental=True，同时不保留该行
    - 支持特别格式的时间戳，例如 [00:00.00-1]

    返回 ParsedLRC(synced, plain, is_instrumental)
    """
    raw = read_text_any(path)
    raw = raw.replace("\r\n", "\n").replace("\r", "\n")

    synced_lines: List[str] = []
    plain_lines: List[str] = []
    is_instrumental = False

    for line in raw.splitlines():
        s = line.strip()

        # 空行：丢进 synced / plain 里，保持段落结构
        if not s:
            synced_lines.append("")
            plain_lines.append("")
            continue

        # LRC 头部标签：仅保留在 synced
        if HEADER_TAG_RE.match(s):
            synced_lines.append(line)
            continue

        # 去掉所有时间标签，得到纯文本部分
        text_no_tag = TIMESTAMP_RE.sub("", s).strip()

        # 检测“纯音乐，请欣赏”类提示
        if text_no_tag and any(p in text_no_tag for p in PURE_MUSIC_PHRASES):
            is_instrumental = True
            # 这类提示不用出现在 synced / plain 中
            continue

        # 检测 credit：作词/作曲/混音/母带/缩混/录音/制作/监制/和声/配唱 等
        if text_no_tag and CREDIT_RE.match(text_no_tag):
            # 整行丢弃，不保留到 synced / plain
            continue

        # 正常歌词行：保留原始行到 synced，将去掉 timestamp 的内容进入 plain
        synced_lines.append(line)
        plain_lines.append(text_no_tag)

    # 去掉 plain 顶部 / 尾部空行，使展示更干净
    while plain_lines and not plain_lines[0]:
        plain_lines.pop(0)
    while plain_lines and not plain_lines[-1]:
        plain_lines.pop()

    synced = "\n".join(synced_lines)
    plain = "\n".join(plain_lines)

    return ParsedLRC(
        synced=synced,
        plain=plain,
        is_instrumental=is_instrumental,
    )

===== FILE: pylrclibup/model/track.py =====
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Optional

from mutagen import File as MutaFile
from mutagen.id3 import ID3NoHeaderError

from ..exceptions import PylrclibupError


@dataclass
class TrackMeta:
    """
    表示一首歌曲的元数据（从 MP3 文件读取）：
      - path: MP3 文件路径
      - track: 歌曲名
      - artist: 艺术家名（可能含 feat. 等）
      - album: 专辑名
      - duration: 秒数
    """

    path: Path
    track: str
    artist: str
    album: str
    duration: int  # 秒

    def __str__(self) -> str:
        return f"{self.artist} - {self.track} ({self.album}, {self.duration}s)"

    # --------------------------------------------------

    @staticmethod
    def _get_tag(tags, key: str) -> Optional[str]:
        """从 Mutagen 的 tag 对象中安全获取 text 字段"""
        field = tags.get(key)
        return field.text[0] if field and getattr(field, "text", None) else None

    # --------------------------------------------------

    @classmethod
    def from_mp3(cls, mp3_path: Path) -> Optional["TrackMeta"]:
        """
        从 MP3 文件读取元数据。
        出现异常/标签不完整时返回 None（processor 决定如何处理）。
        """

        try:
            audio = MutaFile(mp3_path)
            if audio is None or audio.tags is None:
                print(f"[WARN] 无法读取标签：{mp3_path.name}")
                return None
        except ID3NoHeaderError:
            print(f"[WARN] 无 ID3 标签：{mp3_path.name}")
            return None
        except Exception as e:
            print(f"[ERROR] 读取标签异常 {mp3_path.name}: {e}")
            return None

        tags = audio.tags

        track = cls._get_tag(tags, "TIT2")
        artist = cls._get_tag(tags, "TPE1")
        album = cls._get_tag(tags, "TALB")

        if not track or not artist or not album:
            print(f"[WARN] 标签不完整：{mp3_path.name}")
            return None

        duration = int(round(getattr(audio.info, "length", 0)))
        if duration <= 0:
            print(f"[WARN] 时长无效：{mp3_path.name}")
            return None

        return cls(
            path=mp3_path,
            track=track,
            artist=artist,
            album=album,
            duration=duration,
        )

===== FILE: pylrclibup/model/lyrics.py =====
from __future__ import annotations

from dataclasses import dataclass
from typing import Optional


@dataclass
class LyricsRecord:
    """
    表示从 LRCLIB API（/api/get /api/get-cached 等）获得的歌词记录。
    """

    track_name: str
    artist_name: str
    album_name: str
    duration: int

    plain: str
    synced: str
    instrumental: bool

    @classmethod
    def from_api(cls, data: dict) -> "LyricsRecord":
        plain = data.get("plainLyrics") or ""
        synced = data.get("syncedLyrics") or ""
        instrumental = bool(data.get("instrumental")) or (not plain and not synced)

        return cls(
            track_name=data.get("trackName") or "",
            artist_name=data.get("artistName") or "",
            album_name=data.get("albumName") or "",
            duration=int(data.get("duration", 0)),
            plain=plain,
            synced=synced,
            instrumental=instrumental,
        )

===== FILE: pylrclibup/model/__init__.py =====
from .track import TrackMeta
from .lyrics import LyricsRecord

__all__ = ["TrackMeta", "LyricsRecord"]

===== FILE: pylrclibup/api/pow.py =====
from __future__ import annotations

import hashlib

from ..exceptions import PoWError


def solve_pow(prefix: str, target_hex: str) -> str:
    """
    按官方说明 + LRCGET 的实现习惯：

    - target 是 16 进制字符串，表示一个 256 位整数阈值
    - 在 nonce 为 0,1,2,... 中寻找第一个满足：
        sha256(prefix + str(nonce)) <= target
    - 返回 nonce 的十进制字符串
    """
    if not prefix or not target_hex:
        raise PoWError(f"无效 PoW 参数：prefix={prefix!r}, target={target_hex!r}")

    target = int(target_hex, 16)

    nonce = 0
    while True:
        token_bytes = (prefix + str(nonce)).encode("utf-8")
        digest = hashlib.sha256(token_bytes).hexdigest()
        if int(digest, 16) <= target:
            print(f"[INFO] Found nonce: {nonce}")
            return str(nonce)
        nonce += 1

===== FILE: pylrclibup/api/client.py =====
from __future__ import annotations

from typing import Optional

from ..config import AppConfig
from ..model import TrackMeta, LyricsRecord
from .http import http_request_json
from .publish import (
    upload_lyrics as _upload_lyrics_impl,
    upload_instrumental as _upload_instrumental_impl,
)


def _log_info(msg: str) -> None:
    print(f"[INFO] {msg}")


def _log_warn(msg: str) -> None:
    print(f"[WARN] {msg}")


def _check_duration(meta: TrackMeta, record: dict, label: str) -> None:
    """
    打印 LRCLIB 返回的 duration 与本地 duration 的差值提示。
    逻辑与之前单文件脚本中的实现一致。
    """
    rec_dur = record.get("duration")
    if rec_dur is None:
        return

    try:
        rec_dur_int = int(round(float(rec_dur)))
    except Exception:
        return

    diff = abs(rec_dur_int - meta.duration)
    if diff <= 2:
        _log_info(
            f"{label} 时长检查：LRCLIB={rec_dur_int}s, "
            f"本地={meta.duration}s, 差值={diff}s（<=2s，符合匹配条件）"
        )
    else:
        _log_warn(
            f"{label} 时长检查：LRCLIB={rec_dur_int}s, "
            f"本地={meta.duration}s, 差值={diff}s（>2s，可能不是同一首）"
        )


class ApiClient:
    """
    高层 API 封装：

    - get_cached()  : 调用 /api/get-cached，只查内部数据库
    - get_external(): 调用 /api/get，会触发 LRCLIB 外部抓取
    - upload_lyrics(): 语义化包装 /api/publish（带歌词）
    - upload_instrumental(): 语义化包装 /api/publish（纯音乐）

    说明：
      * 处理时长 ±2 秒的提示逻辑仍与早期脚本一致。
      * HTTP 重试、User-Agent、基地址等逻辑，全部由 AppConfig 控制，
        具体在 http_request_json() 和 publish.py 中实现。
    """

    def __init__(self, config: AppConfig) -> None:
        self.config = config

    # -------- 内部通用 GET 封装 --------

    def _api_get_common(
        self,
        meta: TrackMeta,
        endpoint: str,
        label: str,
    ) -> Optional[LyricsRecord]:
        """
        通用的 /api/get* 调用逻辑：

        - 使用 track / artist / album / duration 构造 query 参数
        - 调用 http_request_json（带自动重试）
        - 如有返回则包装为 LyricsRecord
        """
        params = {
            "track_name": meta.track,
            "artist_name": meta.artist,
            "album_name": meta.album,
            "duration": meta.duration,
        }

        url = f"{self.config.lrclib_base}/{endpoint}"

        data = http_request_json(
            self.config,
            method="GET",
            url=url,
            label=label,
            params=params,
        )
        if not data:
            return None

        _check_duration(meta, data, label)
        return LyricsRecord.from_api(data)

    # -------- 公共方法：GET cached --------

    def get_cached(self, meta: TrackMeta) -> Optional[LyricsRecord]:
        """
        调用 /api/get-cached：
          - 只查 LRCLIB 内部数据库
          - 不触发外部抓取
          - 未命中返回 None
        """
        return self._api_get_common(meta, "get-cached", "内部数据库 (/api/get-cached)")

    # -------- 公共方法：GET external --------

    def get_external(self, meta: TrackMeta) -> Optional[LyricsRecord]:
        """
        调用 /api/get：
          - 若内部没有，会触发 LRCLIB 对外部来源的抓取
          - 未命中返回 None
        """
        return self._api_get_common(meta, "get", "外部抓取 (/api/get)")

    # -------- 公共方法：上传歌词 / 纯音乐（可选给库用户用） --------

    def upload_lyrics(self, meta: TrackMeta, plain: str, synced: str) -> bool:
        """
        高层包装：上传带 plain+synced 的歌词。
        （processor 层目前直接用 publish.upload_lyrics(config, meta, ...)，
         但如果你想在别处以面向对象方式使用，也可以通过 ApiClient 调用。）
        """
        return _upload_lyrics_impl(self.config, meta, plain, synced)

    def upload_instrumental(self, meta: TrackMeta) -> bool:
        """
        高层包装：以“纯音乐”方式上传（不包含任何歌词文本）。
        """
        return _upload_instrumental_impl(self.config, meta)

===== FILE: pylrclibup/api/__init__.py =====
from .client import ApiClient
from .publish import (
    build_payload_for_publish,
    upload_lyrics,
    upload_instrumental,
)

__all__ = [
    "ApiClient",
    "build_payload_for_publish",
    "upload_lyrics",
    "upload_instrumental",
]

===== FILE: pylrclibup/api/http.py =====
from __future__ import annotations

import time
from typing import Optional, Dict, Any

import requests
from requests import RequestException

from ..config import AppConfig


def _log_info(msg: str) -> None:
    print(f"[INFO] {msg}")


def _log_warn(msg: str) -> None:
    print(f"[WARN] {msg}")


def _log_error(msg: str) -> None:
    print(f"[ERROR] {msg}")


def http_request_json(
    config: AppConfig,
    method: str,
    url: str,
    label: str,
    *,
    params: Optional[Dict[str, Any]] = None,
    json_data: Optional[Dict[str, Any]] = None,
    timeout: int = 20,
    max_retries: Optional[int] = None,
    treat_404_as_none: bool = True,
) -> Optional[Dict[str, Any]]:
    """
    封装 GET / POST JSON 请求的通用函数：

    - 遵循 config.max_http_retries 进行重试
    - 对网络异常 / 5xx 做自动重试
    - 404 可选视为 None
    - 其余 4xx 报错后不重试
    """
    retries = max_retries if max_retries is not None else config.max_http_retries

    for attempt in range(1, retries + 1):
        try:
            resp = requests.request(
                method=method,
                url=url,
                params=params,
                json=json_data,
                timeout=timeout,
                headers={"User-Agent": config.user_agent},
            )
        except RequestException as e:
            _log_warn(f"{label} 调用失败（第 {attempt}/{retries} 次自动重试）: {e}")
            if attempt == retries:
                return None
            time.sleep(1)
            continue

        # 特殊处理 404
        if resp.status_code == 404 and treat_404_as_none:
            return None

        if 200 <= resp.status_code < 300:
            try:
                return resp.json()
            except ValueError as e:
                _log_warn(
                    f"{label} 解析 JSON 失败: {e} "
                    f"(status={resp.status_code}, body={resp.text[:200]!r})"
                )
                return None

        # 4xx 默认认为是参数/认证问题，不重试
        if 400 <= resp.status_code < 500:
            _log_warn(
                f"{label} 请求失败：HTTP {resp.status_code}, body={resp.text[:200]!r}"
            )
            return None

        # 5xx → 重试
        _log_warn(
            f"{label} 请求失败：HTTP {resp.status_code}, "
            f"body={resp.text[:200]!r}（第 {attempt}/{retries} 次自动重试）"
        )
        if attempt == retries:
            return None
        time.sleep(1)

    return None

===== FILE: pylrclibup/api/publish.py =====
from __future__ import annotations

import time
from typing import Optional, Dict, Any

import requests
from requests import RequestException

from ..config import AppConfig
from ..exceptions import PublishTokenError
from ..model import TrackMeta
from .http import http_request_json
from .pow import solve_pow


def _log_info(msg: str) -> None:
    print(f"[INFO] {msg}")


def _log_warn(msg: str) -> None:
    print(f"[WARN] {msg}")


def _log_error(msg: str) -> None:
    print(f"[ERROR] {msg}")


# -------------------- Publish Token / PoW --------------------


def request_publish_token(config: AppConfig) -> Optional[str]:
    """
    调用 /api/request-challenge，执行 PoW，返回完整的
      X-Publish-Token = "{prefix}:{nonce}"
    """
    url = f"{config.lrclib_base}/request-challenge"
    data = http_request_json(
        config,
        "POST",
        url,
        "请求发布令牌 (/api/request-challenge)",
        treat_404_as_none=False,
    )
    if not data:
        return None

    prefix = data.get("prefix")
    target = data.get("target")
    if not prefix or not target:
        _log_error(f"请求发布令牌返回异常数据：{data}")
        return None

    try:
        nonce = solve_pow(prefix, target)
    except Exception as e:
        _log_error(f"PoW 求解失败：{e}")
        return None

    return f"{prefix}:{nonce}"


# -------------------- Publish with retry --------------------


def publish_with_retry(
    config: AppConfig,
    meta: TrackMeta,
    payload: Dict[str, Any],
    label: str,
) -> bool:
    """
    对 /api/publish 做一层自动重试：
      - 每次重试都会重新请求 challenge + 重新 PoW
      - 成功（201）即返回 True
      - 4xx 认为是参数或 Token 问题，不重试
    """
    url = f"{config.lrclib_base}/publish"
    retries = config.max_http_retries

    for attempt in range(1, retries + 1):
        token = request_publish_token(config)
        if not token:
            _log_warn(
                f"{label}：获取发布令牌失败（第 {attempt}/{retries} 次自动重试）"
            )
            if attempt == retries:
                return False
            time.sleep(1)
            continue

        headers = {
            "X-Publish-Token": token,
            "Content-Type": "application/json",
            "User-Agent": config.user_agent,
        }

        try:
            resp = requests.post(url, json=payload, headers=headers, timeout=30)
        except RequestException as e:
            _log_warn(
                f"{label} (/api/publish) 调用失败（第 {attempt}/{retries} 次自动重试）: {e}"
            )
            if attempt == retries:
                return False
            time.sleep(1)
            continue

        if resp.status_code == 201:
            return True

        # 4xx: 参数/Token 错误，不再重试
        if 400 <= resp.status_code < 500:
            _log_error(
                f"{label} 失败：HTTP {resp.status_code}, body={resp.text[:200]!r} "
                "（4xx 错误，一般是参数或 Token 问题，不再重试）"
            )
            return False

        # 5xx: 重试
        _log_warn(
            f"{label} 失败：HTTP {resp.status_code}, body={resp.text[:200]!r} "
            f"（第 {attempt}/{retries} 次自动重试）"
        )
        if attempt == retries:
            return False
        time.sleep(1)

    return False


# -------------------- Payload 构造 --------------------


def build_payload_for_publish(
    meta: TrackMeta,
    plain: Optional[str],
    synced: Optional[str],
    *,
    force_instrumental: bool = False,
) -> Dict[str, Any]:
    """
    构造 /api/publish 的 JSON：

    - 若 force_instrumental=True 或 plain/synced 均为空/空白：
        → 不包含 plainLyrics/syncedLyrics 字段
        → 按官方说明：该曲目应被标记为 instrumental
    - 否则：
        → 同时包含 plainLyrics / syncedLyrics
    """
    base: Dict[str, Any] = {
        "trackName": meta.track,
        "artistName": meta.artist,
        "albumName": meta.album,
        "duration": meta.duration,
    }

    if force_instrumental:
        return base

    p = (plain or "").strip()
    s = (synced or "").strip()

    if not p and not s:
        # 两个都确实空 → 也按 instrumental 处理，不附带歌词字段
        return base

    base["plainLyrics"] = p
    base["syncedLyrics"] = s
    return base


# -------------------- 高阶上传函数（给 processor 用） --------------------


def upload_lyrics(
    config: AppConfig,
    meta: TrackMeta,
    plain: str,
    synced: str,
) -> bool:
    payload = build_payload_for_publish(
        meta,
        plain,
        synced,
        force_instrumental=False,
    )
    return publish_with_retry(config, meta, payload, "上传歌词")


def upload_instrumental(
    config: AppConfig,
    meta: TrackMeta,
) -> bool:
    """
    按“纯音乐曲目”上传：
      - 不传任何歌词字段
      - 依赖服务器将其标记为 instrumental
    """
    payload = build_payload_for_publish(
        meta,
        plain=None,
        synced=None,
        force_instrumental=True,
    )
    return publish_with_retry(config, meta, payload, "上传纯音乐标记")

===== FILE: pylrclibup/exceptions.py =====
from __future__ import annotations


class PylrclibupError(Exception):
    """包内自定义异常的基类。"""


class NetworkError(PylrclibupError):
    """表示网络相关错误（如多次重试仍失败）。"""


class PublishTokenError(PylrclibupError):
    """获取或验证发布 Token 失败。"""


class PoWError(PylrclibupError):
    """PoW 求解失败或 challenge 数据异常。"""


class ApiResponseError(PylrclibupError):
    """LRCLIB API 返回了非预期的响应。"""


class LrcNotFoundError(PylrclibupError):
    """为某首歌找不到对应的 LRC 文件。"""


class InstrumentalDetected(PylrclibupError):
    """
    标记解析过程中检测到纯音乐。
    在某些高级用法下，可能希望通过异常来中断普通歌词流程。
    """

===== FILE: pylrclibup/fs/mover.py =====
from __future__ import annotations

from pathlib import Path


def move_with_dedup(src: Path, dst_dir: Path) -> Path | None:
    """
    将 src 移动到 dst_dir，若同名文件已存在，则自动添加 _dup 后缀。

    返回最终路径；若失败返回 None。
    """
    try:
        dst_dir.mkdir(parents=True, exist_ok=True)
        target = dst_dir / src.name

        # 处理重名情况
        if target.exists():
            stem = target.stem
            suffix = target.suffix
            dedup = 1
            while True:
                candidate = dst_dir / f"{stem}_dup{dedup}{suffix}"
                if not candidate.exists():
                    target = candidate
                    break
                dedup += 1

        src.rename(target)
        return target

    except Exception as e:
        print(f"[WARN] 移动文件失败：{src} → {dst_dir}：{e}")
        return None

===== FILE: pylrclibup/fs/paths.py =====
from __future__ import annotations

from pathlib import Path
from dataclasses import dataclass

from ..config import AppConfig


@dataclass
class FsPaths:
    """
    根据 AppConfig 构建所有相关路径。

    使用：
        paths = FsPaths.from_config(config)
        paths.tracks_dir
        paths.lrc_dir
        paths.done_tracks_dir
        paths.done_lrc_dir
    """

    root: Path
    tracks_dir: Path
    lrc_dir: Path
    done_tracks_dir: Path
    done_lrc_dir: Path

    @classmethod
    def from_config(cls, config: AppConfig) -> "FsPaths":
        tracks = Path(config.tracks_dir).resolve()
        lrcs = Path(config.lrc_dir).resolve()
        done_tracks = Path(config.done_tracks_dir).resolve()
        done_lrcs = Path(config.done_lrc_dir).resolve()

        # 随便给 root 一个公共前缀（可选）
        root = tracks.parent

        for d in (tracks, lrcs, done_tracks, done_lrcs):
            d.mkdir(parents=True, exist_ok=True)

        return cls(
            root=root,
            tracks_dir=tracks,
            lrc_dir=lrcs,
            done_tracks_dir=done_tracks,
            done_lrc_dir=done_lrcs,
        )

===== FILE: pylrclibup/fs/__init__.py =====
from .paths import FsPaths
from .mover import move_with_dedup
from .cleaner import cleanup_empty_dirs

__all__ = [
    "FsPaths",
    "move_with_dedup",
    "cleanup_empty_dirs",
]

===== FILE: pylrclibup/fs/cleaner.py =====
from __future__ import annotations

from pathlib import Path


def cleanup_empty_dirs(root: Path) -> None:
    """
    从 root 开始向下递归删除空目录（保留 root 本身）。
    """

    if not root.exists():
        return

    # 按目录深度从深到浅排序
    dirs = sorted(
        (p for p in root.rglob("*") if p.is_dir()),
        key=lambda p: len(p.parts),
        reverse=True,
    )

    for d in dirs:
        try:
            # if empty
            if not any(d.iterdir()):
                d.rmdir()
        except Exception:
            # 非空或无权限，忽略
            pass

